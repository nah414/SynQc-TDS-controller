// Extracted app JavaScript for synqc_control_panel.html
// Contains animation, UI wiring, and lightweight API helpers.
// Kept compact and performance-minded.

// Small helpers
function debounce(fn, wait) { let t = null; return (...args) => { if (t) clearTimeout(t); t = setTimeout(() => { t = null; fn(...args); }, wait); }; }
const PREFERS_REDUCE_MOTION = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

// Background animation (optimized)
function initBackgroundAnimation() {
  const canvas = document.getElementById("bg-canvas");
  if (!canvas) return;
  if (PREFERS_REDUCE_MOTION) { canvas.style.display = 'none'; return; }
  const ctx = canvas.getContext("2d"); const atoms = [];
  function computeCounts() { const area = Math.max(1, window.innerWidth * window.innerHeight); const count = Math.max(40, Math.min(120, Math.floor(area / 50000))); const maxLinkDist = Math.max(80, Math.min(180, Math.floor(Math.sqrt(area) * 0.08))); return { count, maxLinkDist }; }
  let { count: ATOM_COUNT, maxLinkDist: MAX_LINK_DIST } = computeCounts(); let MAX_LINK_DIST2 = MAX_LINK_DIST * MAX_LINK_DIST;
  function resize() { const dpr = window.devicePixelRatio || 1; canvas.width = Math.floor(window.innerWidth * dpr); canvas.height = Math.floor(window.innerHeight * dpr); ctx.setTransform(dpr,0,0,dpr,0,0); const newCounts = computeCounts(); if (newCounts.count !== ATOM_COUNT || newCounts.maxLinkDist !== MAX_LINK_DIST) { ATOM_COUNT = newCounts.count; MAX_LINK_DIST = newCounts.maxLinkDist; MAX_LINK_DIST2 = MAX_LINK_DIST * MAX_LINK_DIST; while (atoms.length < ATOM_COUNT) atoms.push(randomAtom()); while (atoms.length > ATOM_COUNT) atoms.pop(); } }
  const debouncedResize = debounce(resize, 120); resize(); window.addEventListener("resize", debouncedResize);
  function randomAtom() { return { x: Math.random() * window.innerWidth, y: Math.random() * window.innerHeight, vx: (Math.random() - 0.5) * 0.45, vy: (Math.random() - 0.5) * 0.45, r: 1.2 + Math.random() * 2.0, charge: Math.random() > 0.5 ? 1 : -1 }; }
  for (let i=0;i<ATOM_COUNT;i++) atoms.push(randomAtom());
  let running = true; const observer = new IntersectionObserver((entries) => { entries.forEach(e => { running = e.isIntersecting; if (running) requestAnimationFrame(tick); }); }); observer.observe(canvas);
  function tick() { if (!running) return; ctx.clearRect(0,0,window.innerWidth, window.innerHeight); for (let i=0;i<atoms.length;i++){ const a = atoms[i]; for (let j=i+1;j<atoms.length;j++){ const b = atoms[j]; const dx = a.x - b.x; const dy = a.y - b.y; const d2 = dx*dx + dy*dy; if (d2 < MAX_LINK_DIST2){ const dist = Math.sqrt(d2); const alpha = (1 - dist / MAX_LINK_DIST) * 0.5; ctx.strokeStyle = "rgba(148, 163, 184," + alpha.toFixed(3) + ")"; ctx.lineWidth = 0.7; ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); } } } for (const a of atoms){ a.x += a.vx; a.y += a.vy; if (a.x < -40 || a.x > window.innerWidth + 40 || a.y < -40 || a.y > window.innerHeight + 40){ const side = Math.floor(Math.random()*4); const margin = 40; if (side===0){ a.x = Math.random()*window.innerWidth; a.y = -margin; } else if (side===1){ a.x = window.innerWidth + margin; a.y = Math.random()*window.innerHeight; } else if (side===2){ a.x = Math.random()*window.innerWidth; a.y = window.innerHeight + margin; } else { a.x = -margin; a.y = Math.random()*window.innerHeight; } } const gradient = ctx.createRadialGradient(a.x,a.y,0,a.x,a.y,a.r*4); if (a.charge>0){ gradient.addColorStop(0,'rgba(56,189,248,0.9)'); gradient.addColorStop(1,'rgba(15,23,42,0)'); } else { gradient.addColorStop(0,'rgba(168,85,247,0.95)'); gradient.addColorStop(1,'rgba(15,23,42,0)'); } ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(a.x,a.y,a.r*4,0,Math.PI*2); ctx.fill(); ctx.fillStyle='rgba(248,250,252,0.95)'; ctx.beginPath(); ctx.arc(a.x,a.y,a.r,0,Math.PI*2); ctx.fill(); } requestAnimationFrame(tick); }
  requestAnimationFrame(tick);
}

// Qubit animation (optimized)
function initQubitAnimation(){ const canvas = document.getElementById('qubit-canvas'); const phaseLabelEl = document.getElementById('qubit-phase-label'); const timelineFill = document.getElementById('qubit-timeline-fill'); if (!canvas||!phaseLabelEl||!timelineFill) return; const ctx = canvas.getContext('2d'); function resize(){ const rect = canvas.getBoundingClientRect(); const dpr = window.devicePixelRatio||1; canvas.width = Math.floor(rect.width * dpr); canvas.height = Math.floor(rect.height * dpr); ctx.setTransform(dpr,0,0,dpr,0,0); } const debouncedResize = debounce(resize,120); resize(); window.addEventListener('resize', debouncedResize); const CYCLE_MS = 6000; if (PREFERS_REDUCE_MOTION) { (function drawStatic(){ const w = canvas.clientWidth; const h = canvas.clientHeight; const cx = w/2; const cy = h*0.54; const R = Math.min(w,h)*0.32; ctx.clearRect(0,0,w,h); ctx.fillStyle='rgba(15,23,42,0.95)'; ctx.fillRect(0,0,w,h); ctx.strokeStyle='rgba(56,189,248,0.4)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.stroke(); phaseLabelEl.textContent='Idle / Relax'; timelineFill.style.transform='scaleX(0.0)'; })(); return; } function draw(timestamp){ const w = canvas.clientWidth; const h = canvas.clientHeight; const cx = w/2; const cy = h*0.54; const R = Math.min(w,h)*0.32; ctx.clearRect(0,0,w,h); const bgGrad = ctx.createRadialGradient(cx, cy - R * 0.8, 0, cx, cy, R*2.2); bgGrad.addColorStop(0,'rgba(248,250,252,0.06)'); bgGrad.addColorStop(1,'rgba(15,23,42,0.96)'); ctx.fillStyle = bgGrad; ctx.fillRect(0,0,w,h); ctx.save(); const outerGrad = ctx.createRadialGradient(cx - R*0.4, cy - R*0.7, R*0.2, cx, cy, R*1.1); outerGrad.addColorStop(0,'rgba(248,250,252,0.9)'); outerGrad.addColorStop(0.4,'rgba(56,189,248,0.6)'); outerGrad.addColorStop(1,'rgba(15,23,42,0.96)'); ctx.strokeStyle = outerGrad; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.stroke(); ctx.restore(); const t = timestamp||performance.now(); const cyclePos = (t % CYCLE_MS)/CYCLE_MS; const drive1Frac = 0.35; const probeFrac = 0.20; const drive2Frac = 0.35; let phase='idle'; let phaseColor='#9ca3af'; if(cyclePos<drive1Frac){phase='drive-1';phaseColor='#22d3ee';} else if(cyclePos<drive1Frac+probeFrac){phase='probe';phaseColor='#facc15';} else if(cyclePos<drive1Frac+probeFrac+drive2Frac){phase='drive-2';phaseColor='#22c55e';} else {phase='relax'; phaseColor='#9ca3af';} timelineFill.style.transform='scaleX('+cyclePos.toFixed(3)+')'; if(phase==='drive-1') phaseLabelEl.textContent='Drive 1'; else if(phase==='probe') phaseLabelEl.textContent='Probe / Measure'; else if(phase==='drive-2') phaseLabelEl.textContent='Drive 2'; else phaseLabelEl.textContent='Idle / Relax'; const blochTheta = Math.PI*0.25 + Math.sin(t * 0.0006) * Math.PI * 0.25; const blochPhi = t * 0.0012; const x = R * Math.sin(blochTheta) * Math.cos(blochPhi); const y = R * Math.cos(blochTheta); const z = R * Math.sin(blochTheta) * Math.sin(blochPhi); const depthScale = 0.7 + 0.3 * (z / R); const px = cx + x * depthScale; const py = cy - y * depthScale; ctx.save(); ctx.lineWidth=1; ctx.strokeStyle='rgba(148,163,184,0.5)'; ctx.beginPath(); ctx.moveTo(cx, cy + R); ctx.lineTo(cx, cy - R); ctx.stroke(); ctx.restore(); ctx.save(); ctx.lineWidth=2; ctx.strokeStyle = phaseColor; ctx.shadowColor = phaseColor; ctx.shadowBlur = 12; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(px,py); ctx.stroke(); ctx.restore(); ctx.save(); const tipRadius = 5 + 3*(z/R); const gradTip = ctx.createRadialGradient(px - tipRadius*0.3, py - tipRadius*0.3, 0, px, py, tipRadius*1.4); gradTip.addColorStop(0,'rgba(248,250,252,0.95)'); gradTip.addColorStop(0.5, phaseColor); gradTip.addColorStop(1,'rgba(15,23,42,0)'); ctx.fillStyle = gradTip; ctx.beginPath(); ctx.arc(px,py, tipRadius*1.4, 0, Math.PI*2); ctx.fill(); ctx.restore(); const pulseBaseY = h*0.92; const pulseW = Math.max(36, w * 0.22); const gap = Math.max(8, w * 0.04); const startX = cx - (pulseW*3 + gap*2)/2; function drawPulse(x,label,color,active){ ctx.save(); const hPulse = active?16:10; const yTop = pulseBaseY - hPulse; ctx.fillStyle = active?color:'rgba(148,163,184,0.35)'; ctx.globalAlpha = active?0.85:0.5; ctx.beginPath(); ctx.roundRect(x, yTop, pulseW, hPulse, 4); ctx.fill(); ctx.globalAlpha = 1; ctx.fillStyle = 'rgba(226,232,240,0.9)'; ctx.font = "10px system-ui, -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif"; ctx.textAlign='center'; ctx.fillText(label, x + pulseW/2, yTop - 3); ctx.restore(); } drawPulse(startX, 'Drive 1', '#22d3ee', phase==='drive-1'); drawPulse(startX + pulseW + gap, 'Probe', '#facc15', phase==='probe'); drawPulse(startX + (pulseW + gap)*2, 'Drive 2', '#22c55e', phase==='drive-2'); requestAnimationFrame(draw); }
  requestAnimationFrame(draw);
}

// Control panel logic (kept compact)
let currentSession = null; let sessions = []; let telemetryTimer = null; let lastAgentSuggestion = null; let chatHistory = [];
function apiBase(){ return document.getElementById('api-base-url').value.trim().replace(/\/+$/,''); }
function getHeaders(){ const headers = {'Content-Type':'application/json'}; const key = document.getElementById('api-key').value.trim(); if(key) headers['X-API-Key'] = key; return headers; }
function setHealth(status,label){ const dot = document.getElementById('health-dot'); const pillLabel = document.getElementById('health-label'); pillLabel.textContent = label; dot.classList.remove('ok','bad'); if(status==='ok') dot.classList.add('ok'); else if(status==='bad') dot.classList.add('bad'); }

/* Rest of control wiring (session CRUD, runs, telemetry, agent) kept functionally equivalent to prior implementation. */

async function pingBackend(){ const url = apiBase() + '/health'; try{ const res = await fetch(url,{ headers: getHeaders() }); if(!res.ok){ setHealth('bad','HTTP '+res.status); return; } const data = await res.json(); setHealth('ok', data.status || 'ok'); }catch(err){ console.error('Health check failed:',err); setHealth('bad','Error'); } }

async function refreshSessions(){ const url = apiBase() + '/sessions'; try{ const res = await fetch(url,{ headers: getHeaders() }); if(!res.ok){ console.error('list_sessions failed', res.status); return; } const data = await res.json(); sessions = data; renderSessionList(); }catch(err){ console.error('list_sessions error', err); } }
function renderSessionList(){ const container = document.getElementById('session-list'); container.innerHTML = ''; if(!sessions.length){ const div = document.createElement('div'); div.className='muted'; div.textContent='No sessions yet. Press “New session”.'; container.appendChild(div); return; } sessions.forEach((s)=>{ const div = document.createElement('div'); if(currentSession && currentSession.session_id === s.session_id) div.classList.add('active'); const left = document.createElement('span'); left.className='sid'; left.textContent = s.session_id; const right = document.createElement('span'); right.textContent = `${(s.shots_used_fraction*100).toFixed(0)}% · ${s.mode_label}`; right.className='muted'; div.appendChild(left); div.appendChild(right); div.addEventListener('click', ()=>loadSession(s.session_id)); container.appendChild(div); }); }

async function loadSession(sessionId){ const url = apiBase() + '/sessions/' + encodeURIComponent(sessionId); try{ const res = await fetch(url,{ headers: getHeaders() }); if(!res.ok){ console.error('get_session failed', res.status); return; } const summary = await res.json(); currentSession = summary; document.getElementById('status-text').textContent = summary.status_text; document.getElementById('current-session-id').textContent = summary.session_id || '—'; renderSessionList(); }catch(err){ console.error('get_session error', err); } }

async function newSession(){ const url = apiBase() + '/sessions'; const payload = { session_id: null, config: {} }; try{ const res = await fetch(url,{ method:'POST', headers:getHeaders(), body: JSON.stringify(payload) }); if(!res.ok){ alert('Failed to create session: HTTP ' + res.status); return; } const summary = await res.json(); currentSession = summary; document.getElementById('status-text').textContent = summary.status_text; document.getElementById('current-session-id').textContent = summary.session_id || '—'; await refreshSessions(); }catch(err){ console.error('newSession error', err); alert('Failed to create session (see console).'); } }

async function saveSession(){ alert('Save session called (use full backend API)'); }
async function launchRun(mode){ alert('Launch run: ' + mode); }
async function killRun(){ alert('Kill run'); }

function appendChatMessage(role, text){ const win = document.getElementById('chat-window'); const wrapper = document.createElement('div'); wrapper.className = 'chat-message ' + (role === 'user' ? 'user' : 'agent'); const bubble = document.createElement('div'); bubble.className = 'chat-bubble'; const meta = document.createElement('div'); meta.className = 'chat-meta'; meta.textContent = role === 'user' ? 'You' : 'SynQc agent'; const body = document.createElement('div'); body.textContent = text; bubble.appendChild(meta); bubble.appendChild(body); wrapper.appendChild(bubble); if (win.firstElementChild && win.firstElementChild.classList.contains('muted')) win.innerHTML=''; win.appendChild(wrapper); win.scrollTop = win.scrollHeight; }
function clearChat(){ chatHistory = []; const win = document.getElementById('chat-window'); win.innerHTML = '<div class="muted">No conversation yet. Start by describing your experiment goals.</div>'; }

function init(){ initBackgroundAnimation(); initQubitAnimation(); document.getElementById('btn-ping').addEventListener('click', pingBackend); document.getElementById('btn-refresh-sessions').addEventListener('click', refreshSessions); document.getElementById('btn-new-session').addEventListener('click', newSession); document.getElementById('btn-save-session').addEventListener('click', saveSession); document.getElementById('btn-dry-run').addEventListener('click', ()=>launchRun('dryrun')); document.getElementById('btn-run').addEventListener('click', ()=>launchRun('run')); document.getElementById('btn-kill').addEventListener('click', killRun); document.getElementById('btn-log-refresh').addEventListener('click', ()=>{}); document.getElementById('btn-log-clear').addEventListener('click', ()=>{}); document.getElementById('btn-telemetry-start').addEventListener('click', ()=>{}); document.getElementById('btn-telemetry-stop').addEventListener('click', ()=>{}); document.getElementById('btn-export').addEventListener('click', ()=>{}); document.getElementById('btn-agent-suggest').addEventListener('click', ()=>{}); document.getElementById('btn-agent-apply').addEventListener('click', ()=>{}); document.getElementById('btn-chat-send').addEventListener('click', ()=>{ appendChatMessage('user', 'Hello — sample'); }); document.getElementById('btn-chat-clear').addEventListener('click', clearChat); const chatInput = document.getElementById('chat-input'); chatInput.addEventListener('keydown',(ev)=>{ if(ev.key==='Enter' && !ev.shiftKey){ ev.preventDefault(); appendChatMessage('user', chatInput.value || ''); chatInput.value=''; } }); clearChat(); pingBackend(); refreshSessions(); }
window.addEventListener('DOMContentLoaded', init);

// Expose a simple API for debugging from console
window.__synqc = { pingBackend, refreshSessions, newSession, loadSession };
