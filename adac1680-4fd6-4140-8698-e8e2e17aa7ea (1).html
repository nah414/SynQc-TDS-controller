<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SynQc Temporal Dynamics Series — Control Panel v0.2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #050812;
      --bg-alt: #0c1020;
      --panel: #111729;
      --accent: #4da3ff;
      --accent-soft: rgba(77, 163, 255, 0.12);
      --accent-strong: rgba(77, 163, 255, 0.3);
      --danger: #ff4d6a;
      --text: #f5f7ff;
      --muted: #9aa4c3;
      --border: #1d2437;
      --radius-lg: 16px;
      --radius-md: 10px;
      --shadow-soft: 0 18px 40px rgba(0, 0, 0, 0.55);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "SF Pro Text", "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #111729 0, #050812 55%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
      padding: 16px;
    }

    .app-shell {
      width: 100%;
      max-width: 1200px;
      background: linear-gradient(135deg, #050812 0, #050812 40%, #090f1f 100%);
      border-radius: 24px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow-soft);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      background: radial-gradient(circle at left, #111729 0, #050812 60%);
    }

    .brand-block {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo-orb {
      width: 32px;
      height: 32px;
      border-radius: 999px;
      background: conic-gradient(
        from 210deg,
        #4da3ff,
        #7b5cff,
        #4da3ff,
        #00e0ff,
        #4da3ff
      );
      box-shadow: 0 0 20px rgba(77, 163, 255, 0.9);
    }

    .brand-text h1 {
      font-size: 18px;
      letter-spacing: 0.03em;
    }

    .brand-text span {
      display: block;
      font-size: 11px;
      text-transform: uppercase;
      color: var(--muted);
    }

    .header-meta {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .tag {
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--accent-strong);
      background: var(--accent-soft);
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.06em;
      white-space: nowrap;
    }

    .tag-secondary {
      border-color: var(--border);
      background: rgba(255, 255, 255, 0.02);
      color: var(--muted);
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 260px) minmax(0, 1fr);
      min-height: 0;
      flex: 1;
    }

    aside {
      border-right: 1px solid var(--border);
      background: var(--bg-alt);
      padding: 16px 14px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    main {
      padding: 16px 18px 18px;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    h2.section-title {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.13em;
      color: var(--muted);
      margin-bottom: 6px;
    }

    .sidebar-card {
      background: rgba(5, 8, 18, 0.9);
      border-radius: var(--radius-md);
      border: 1px solid var(--border);
      padding: 10px 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .sidebar-card h3 {
      font-size: 13px;
      color: var(--text);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .badge-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: var(--accent);
      box-shadow: 0 0 10px rgba(77, 163, 255, 0.9);
    }

    .field-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    label {
      font-size: 11px;
      color: var(--muted);
    }

    select,
    input,
    textarea {
      width: 100%;
      background: #050812;
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 6px 10px;
      font-size: 12px;
      color: var(--text);
      outline: none;
    }

    textarea {
      min-height: 70px;
      border-radius: 12px;
      resize: vertical;
    }

    select:focus,
    input:focus,
    textarea:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(77, 163, 255, 0.3);
    }

    .preset-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .preset-btn {
      width: 100%;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #050812;
      padding: 6px 10px;
      font-size: 11px;
      color: var(--muted);
      text-align: left;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .preset-btn span {
      font-size: 11px;
    }

    .preset-btn strong {
      color: var(--text);
      font-weight: 500;
      margin-right: 4px;
    }

    .preset-btn.active,
    .preset-btn:hover {
      border-color: var(--accent);
      background: linear-gradient(90deg, #050812, rgba(77, 163, 255, 0.1));
      color: var(--text);
    }

    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
    }

    .kpi-card {
      background: var(--panel);
      border-radius: var(--radius-md);
      border: 1px solid var(--border);
      padding: 10px 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .kpi-label {
      font-size: 11px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .kpi-value {
      font-size: 18px;
      font-variant-numeric: tabular-nums;
    }

    .kpi-chip {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: var(--muted);
    }

    .kpi-trend {
      font-size: 11px;
      color: #7de38c;
    }

    .kpi-trend.bad {
      color: var(--danger);
    }

    .tabs {
      display: flex;
      gap: 8px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 6px;
    }

    .tab-btn {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid transparent;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
    }

    .tab-btn.active {
      border-color: var(--accent);
      background: var(--accent-soft);
      color: var(--accent);
    }

    .tab-panel {
      display: none;
      padding-top: 8px;
    }

    .tab-panel.active {
      display: block;
    }

    .panel-card {
      background: var(--panel);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border);
      padding: 12px 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .panel-header h3 {
      font-size: 13px;
    }

    .panel-header p {
      font-size: 11px;
      color: var(--muted);
    }

    .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .chip {
      font-size: 10px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      background: rgba(0, 0, 0, 0.2);
      white-space: nowrap;
    }

    .chip.accent {
      border-color: var(--accent);
      color: var(--accent);
      background: var(--accent-soft);
    }

    .form-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
    }

    .form-grid.wide {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .button-row {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      flex-wrap: wrap;
    }

    .btn {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 7px 12px;
      font-size: 12px;
      cursor: pointer;
      background: rgba(5, 8, 18, 0.9);
      color: var(--muted);
    }

    .btn-primary {
      border-color: var(--accent);
      background: linear-gradient(90deg, #4da3ff, #7b5cff);
      color: #050812;
      font-weight: 500;
    }

    .btn-danger {
      border-color: var(--danger);
      background: transparent;
      color: var(--danger);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: default;
    }

    .log-view {
      background: #050812;
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 8px 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      max-height: 160px;
      overflow-y: auto;
      white-space: pre-wrap;
    }

    .status-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 11px;
      color: var(--muted);
    }

    .status-left {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .status-led {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #555a7c;
    }

    .status-led.live {
      background: #33dd88;
      box-shadow: 0 0 10px rgba(51, 221, 136, 0.9);
    }

    @media (max-width: 880px) {
      .layout {
        grid-template-columns: minmax(0, 1fr);
      }

      aside {
        border-right: none;
        border-bottom: 1px solid var(--border);
      }

      .kpi-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .form-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 600px) {
      .kpi-grid {
        grid-template-columns: minmax(0, 1fr);
      }

      .form-grid,
      .form-grid.wide {
        grid-template-columns: minmax(0, 1fr);
      }
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <header>
      <div class="brand-block">
        <div class="logo-orb" aria-hidden="true"></div>
        <div class="brand-text">
          <h1>SynQc Temporal Dynamics Series</h1>
          <span>Drive–Probe–Drive · Live Control Shell v0.2</span>
        </div>
      </div>
      <div class="header-meta">
        <div class="tag">SynQc · DPD Engine</div>
        <div class="tag tag-secondary" id="session-mode-tag">
          Session Mode: Local Simulation
        </div>
        <div class="tag tag-secondary" id="session-id-tag">
          Session ID: —
        </div>
      </div>
    </header>

    <div class="layout">
      <!-- SIDEBAR -->
      <aside>
        <section>
          <h2 class="section-title">Session</h2>
          <div class="sidebar-card">
            <h3>
              Hardware Stack
              <span class="badge-dot" id="hardware-led"></span>
            </h3>
            <div class="field-group">
              <label for="hardware-target">Target Provider</label>
              <select id="hardware-target">
                <option value="sim-local">Local Simulator (CPU)</option>
                <option value="ibm-qpu">IBM Quantum QPU</option>
                <option value="aws-braket">AWS Braket QPU</option>
                <option value="ionq">IonQ Native</option>
                <option value="classical-only">
                  Classical Hardware Only (FPGA/DAQ)
                </option>
              </select>
            </div>
            <div class="field-group">
              <label for="hardware-preset">Hardware Profile</label>
              <select id="hardware-preset">
                <option value="transmon-default">
                  Transmon Default · 5–27q
                </option>
                <option value="fluxonium-pilot">
                  Fluxonium Pilot · 2–5q
                </option>
                <option value="ion-chain">
                  Trapped-Ion Chain · 11–32q
                </option>
                <option value="neutral-atom">
                  Neutral Atom Array · 100+ sites
                </option>
              </select>
            </div>
          </div>
        </section>

        <section>
          <h2 class="section-title">Templates</h2>
          <div class="sidebar-card">
            <h3>SynQc Presets</h3>
            <div class="preset-list">
              <button class="preset-btn" data-preset="calibration">
                <span><strong>Calibration</strong> · RB + T₁/T₂ sweep</span>
                <span>DPD-Cal</span>
              </button>
              <button class="preset-btn" data-preset="hamiltonian">
                <span><strong>Hamiltonian Scan</strong> · drive map</span>
                <span>DPD-H</span>
              </button>
              <button class="preset-btn" data-preset="stability">
                <span><strong>Stability</strong> · slow drift watch</span>
                <span>DPD-S</span>
              </button>
              <button class="preset-btn" data-preset="realtime">
                <span><strong>Real-time Control</strong> · live feedback</span>
                <span>DPD-RT</span>
              </button>
            </div>
          </div>
        </section>

        <section>
          <h2 class="section-title">Notes</h2>
          <div class="sidebar-card">
            <div class="field-group">
              <label for="session-notes">Run Annotation</label>
              <textarea
                id="session-notes"
                placeholder="e.g. Transmon, 5q, flux-bias sweet spot, 4K, SynQc v0.2 test."
              ></textarea>
            </div>
          </div>
        </section>
      </aside>

      <!-- MAIN -->
      <main>
        <section>
          <h2 class="section-title">Live KPIs</h2>
          <div class="kpi-grid">
            <article class="kpi-card">
              <div class="kpi-label">
                <span>DPD Fidelity</span>
                <span class="kpi-chip">target ≥ 0.975</span>
              </div>
              <div class="kpi-value" id="kpi-fidelity">0.942</div>
              <div class="kpi-trend" id="kpi-fidelity-trend">
                +0.003 vs last run
              </div>
            </article>
            <article class="kpi-card">
              <div class="kpi-label">
                <span>Latency (DPD Loop)</span>
                <span class="kpi-chip">µs end-to-end</span>
              </div>
              <div class="kpi-value" id="kpi-latency">37.4</div>
              <div class="kpi-trend bad" id="kpi-latency-trend">
                +2.1µs vs baseline
              </div>
            </article>
            <article class="kpi-card">
              <div class="kpi-label">
                <span>Probe Back-Action</span>
                <span class="kpi-chip">info vs damage</span>
              </div>
              <div class="kpi-value" id="kpi-backaction">0.18</div>
              <div class="kpi-trend" id="kpi-backaction-trend">
                ↓ acceptable
              </div>
            </article>
            <article class="kpi-card">
              <div class="kpi-label">
                <span>Shot Budget</span>
                <span class="kpi-chip">used / limit</span>
              </div>
              <div class="kpi-value" id="kpi-shots">12.4k / 50k</div>
              <div class="kpi-trend" id="kpi-shots-trend">
                24.8% consumed
              </div>
            </article>
          </div>
        </section>

        <section>
          <div class="tabs" role="tablist">
            <button
              class="tab-btn active"
              data-tab="configure"
              type="button"
              role="tab"
              aria-selected="true"
            >
              Configure Run
            </button>
            <button
              class="tab-btn"
              data-tab="logs"
              type="button"
              role="tab"
              aria-selected="false"
            >
              Logs & Events
            </button>
            <button
              class="tab-btn"
              data-tab="metrics"
              type="button"
              role="tab"
              aria-selected="false"
            >
              Metrics & Export
            </button>
          </div>

          <!-- CONFIGURE TAB -->
          <div
            class="tab-panel active"
            id="tab-configure"
            role="tabpanel"
          >
            <div class="panel-card">
              <div class="panel-header">
                <div>
                  <h3>Drive–Probe–Drive Configuration</h3>
                  <p>
                    Define pulse envelopes, probe window, and adaptive rules
                    before dispatching to your hardware backend.
                  </p>
                </div>
                <div class="chip-row">
                  <div class="chip accent">scheduler</div>
                  <div class="chip accent">probes</div>
                  <div class="chip">demod</div>
                  <div class="chip">adapt</div>
                </div>
              </div>

              <div class="form-grid">
                <div class="field-group">
                  <label for="drive-envelope">Drive Envelope</label>
                  <select id="drive-envelope">
                    <option value="gaussian">Gaussian</option>
                    <option value="square">Square</option>
                    <option value="drag">DRAG</option>
                    <option value="cosine">Cosine-Flat</option>
                  </select>
                </div>
                <div class="field-group">
                  <label for="probe-strength">Probe Strength (ε)</label>
                  <input
                    id="probe-strength"
                    type="number"
                    min="0.0"
                    max="1.0"
                    step="0.01"
                    value="0.20"
                  />
                </div>
                <div class="field-group">
                  <label for="probe-duration">Probe Duration (τₚ, ns)</label>
                  <input
                    id="probe-duration"
                    type="number"
                    min="5"
                    max="5000"
                    step="5"
                    value="120"
                  />
                </div>
              </div>

              <div class="form-grid wide">
                <div class="field-group">
                  <label for="adaptive-rule">Adaptive Rule</label>
                  <select id="adaptive-rule">
                    <option value="none">None (fixed sequence)</option>
                    <option value="kalman">
                      Kalman update · H estimate
                    </option>
                    <option value="bayes">
                      Bayesian branching · probe schedule
                    </option>
                    <option value="rl">
                      RL controller · multi-step objective
                    </option>
                  </select>
                </div>
                <div class="field-group">
                  <label for="objective">Objective</label>
                  <select id="objective">
                    <option value="maximize-fidelity">
                      Maximize DPD fidelity
                    </option>
                    <option value="minimize-latency">
                      Minimize loop latency
                    </option>
                    <option value="info-vs-damage">
                      Info gain vs back-action
                    </option>
                    <option value="stability-window">
                      Stability window over time
                    </option>
                  </select>
                </div>
              </div>

              <div class="button-row">
                <button class="btn btn-danger" id="btn-kill">
                  Kill Switch
                </button>
                <button class="btn" id="btn-dryrun">
                  Dry-Run (no hardware)
                </button>
                <button class="btn btn-primary" id="btn-launch">
                  Launch SynQc Run
                </button>
              </div>
            </div>
          </div>

          <!-- LOGS TAB -->
          <div class="tab-panel" id="tab-logs" role="tabpanel">
            <div class="panel-card">
              <div class="panel-header">
                <div>
                  <h3>Run Log & Events</h3>
                  <p>Streaming diagnostics from scheduler, probes, and backend.</p>
                </div>
                <div class="chip-row">
                  <div class="chip accent">events</div>
                  <div class="chip">warnings</div>
                  <div class="chip">timing</div>
                </div>
              </div>
              <div class="log-view" id="log-view"></div>
              <div class="status-bar">
                <div class="status-left">
                  <span class="status-led" id="status-led"></span>
                  <span id="status-text">Idle · no active run</span>
                </div>
                <button class="btn" id="btn-clear-log">Clear Log</button>
              </div>
            </div>
          </div>

          <!-- METRICS TAB -->
          <div class="tab-panel" id="tab-metrics" role="tabpanel">
            <div class="panel-card">
              <div class="panel-header">
                <div>
                  <h3>Metrics & Export</h3>
                  <p>
                    Snapshot the current KPIs and export them to your SynQc
                    data system for later analysis.
                  </p>
                </div>
                <div class="chip-row">
                  <div class="chip accent">json</div>
                  <div class="chip">csv</div>
                  <div class="chip">notebook</div>
                </div>
              </div>
              <div class="field-group">
                <label for="export-format">Export Format</label>
                <select id="export-format">
                  <option value="json">JSON (API / data lake)</option>
                  <option value="csv">CSV (quick look)</option>
                  <option value="notebook">
                    Notebook cell payload (Jupyter)
                  </option>
                </select>
              </div>
              <div class="button-row">
                <button class="btn btn-primary" id="btn-export">
                  Export Snapshot
                </button>
              </div>
              <div class="log-view" id="export-preview"></div>
            </div>
          </div>
        </section>
      </main>
    </div>
  </div>

  <script>
    // --- tiny util ---
    function $(id) {
      return document.getElementById(id);
    }

    // Tabs
    document.querySelectorAll(".tab-btn").forEach((btn) => {
      btn.addEventListener("click", () => {
        const tab = btn.dataset.tab;

        document
          .querySelectorAll(".tab-btn")
          .forEach((b) => b.classList.remove("active"));
        document
          .querySelectorAll(".tab-panel")
          .forEach((p) => p.classList.remove("active"));

        btn.classList.add("active");
        document.getElementById("tab-" + tab).classList.add("active");
      });
    });

    // Presets
    const presetButtons = document.querySelectorAll(".preset-btn");
    presetButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        presetButtons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        applyPreset(btn.dataset.preset);
      });
    });

    function applyPreset(name) {
      // NOTE: This is where you map presets → real backend configs.
      if (name === "calibration") {
        $("drive-envelope").value = "gaussian";
        $("probe-strength").value = 0.15;
        $("probe-duration").value = 80;
        $("adaptive-rule").value = "none";
        $("objective").value = "maximize-fidelity";
        appendLog("Preset 'Calibration' applied.");
      } else if (name === "hamiltonian") {
        $("drive-envelope").value = "cosine";
        $("probe-strength").value = 0.25;
        $("probe-duration").value = 140;
        $("adaptive-rule").value = "kalman";
        $("objective").value = "info-vs-damage";
        appendLog("Preset 'Hamiltonian Scan' applied.");
      } else if (name === "stability") {
        $("drive-envelope").value = "square";
        $("probe-strength").value = 0.10;
        $("probe-duration").value = 200;
        $("adaptive-rule").value = "bayes";
        $("objective").value = "stability-window";
        appendLog("Preset 'Stability' applied.");
      } else if (name === "realtime") {
        $("drive-envelope").value = "drag";
        $("probe-strength").value = 0.30;
        $("probe-duration").value = 60;
        $("adaptive-rule").value = "rl";
        $("objective").value = "minimize-latency";
        appendLog("Preset 'Real-time Control' applied.");
      }
    }

    // Hardware indicators
    $("hardware-target").addEventListener("change", () => {
      const target = $("hardware-target").value;
      const led = $("hardware-led");
      const tag = $("session-mode-tag");

      if (target === "sim-local") {
        led.style.background = "#33dd88";
        tag.textContent = "Session Mode: Local Simulation";
      } else if (target === "classical-only") {
        led.style.background = "#ffb84d";
        tag.textContent = "Session Mode: Classical Hardware";
      } else {
        led.style.background = "#4da3ff";
        tag.textContent = "Session Mode: Quantum Backend";
      }

      appendLog("Hardware target set to: " + target + ".");
    });

    // Basic log system (front-end only; you wire this to backend later)
    const logView = $("log-view");
    function appendLog(msg) {
      const now = new Date().toISOString();
      logView.textContent += "[" + now + "] " + msg + "
";
      logView.scrollTop = logView.scrollHeight;
    }

    $("btn-clear-log").addEventListener("click", () => {
      logView.textContent = "";
    });

    // Run control
    let runActive = false;
    let fakeKpiInterval = null;

    $("btn-launch").addEventListener("click", () => {
      if (runActive) return;

      runActive = true;
      $("status-led").classList.add("live");
      $("status-text").textContent = "Running · SynQc DPD sequence in progress";
      appendLog("SynQc run launched with current configuration.");

      // mock KPIs so UI feels alive; replace with backend streaming later
      fakeKpiInterval = setInterval(updateFakeKpis, 2200);
    });

    $("btn-dryrun").addEventListener("click", () => {
      appendLog(
        "Dry-run requested. SynQc would build schedule but skip hardware dispatch."
      );
      $("status-text").textContent = "Dry-run complete · no hardware touched";
    });

    $("btn-kill").addEventListener("click", () => {
      if (!runActive) {
        appendLog("Kill switch pressed with no active run.");
        return;
      }
      runActive = false;
      $("status-led").classList.remove("live");
      $("status-text").textContent = "Idle · last run terminated via kill switch";
      appendLog("Kill switch activated. Run terminated safely.");

      if (fakeKpiInterval) {
        clearInterval(fakeKpiInterval);
        fakeKpiInterval = null;
      }
    });

    function updateFakeKpis() {
      function jitter(value, scale, min, max) {
        const delta = (Math.random() - 0.5) * scale;
        let v = value + delta;
        if (min !== undefined) v = Math.max(min, v);
        if (max !== undefined) v = Math.min(max, v);
        return v;
      }

      let fidelity = parseFloat($("kpi-fidelity").textContent);
      let latency = parseFloat($("kpi-latency").textContent);
      let backaction = parseFloat($("kpi-backaction").textContent);

      const newFid = jitter(fidelity || 0.94, 0.004, 0.9, 0.995);
      const newLat = jitter(latency || 38, 3.0, 10, 120);
      const newBack = jitter(backaction || 0.18, 0.03, 0.05, 0.4);

      $("kpi-fidelity-trend").textContent =
        (newFid - fidelity >= 0 ? "+" : "") +
        (newFid - fidelity).toFixed(3) +
        " vs last";
      $("kpi-latency-trend").textContent =
        (newLat - latency >= 0 ? "+" : "") +
        (newLat - latency).toFixed(1) +
        "µs vs last";
      $("kpi-backaction-trend").textContent =
        (newBack - backaction >= 0 ? "↑" : "↓") + " back-action";

      $("kpi-fidelity").textContent = newFid.toFixed(3);
      $("kpi-latency").textContent = newLat.toFixed(1);
      $("kpi-backaction").textContent = newBack.toFixed(2);

      const usedPercent = Math.min(
        99.9,
        parseFloat($("kpi-shots-trend").textContent) + Math.random() * 3
      );
      $("kpi-shots").textContent = (usedPercent * 0.5).toFixed(1) + "k / 50k";
      $("kpi-shots-trend").textContent = usedPercent.toFixed(1) + "% consumed";
    }

    // Export snapshot (front-end only placeholder)
    $("btn-export").addEventListener("click", () => {
      const fmt = $("export-format").value;
      const payload = buildExportPayload(fmt);
      $("export-preview").textContent = payload;
      appendLog("Export snapshot generated (" + fmt + ").");
    });

    function buildExportPayload(fmt) {
      const data = {
        sessionId: $("session-id-tag").textContent.replace("Session ID: ", ""),
        mode: $("session-mode-tag").textContent.replace("Session Mode: ", ""),
        hardwareTarget: $("hardware-target").value,
        hardwarePreset: $("hardware-preset").value,
        driveEnvelope: $("drive-envelope").value,
        probeStrength: parseFloat($("probe-strength").value),
        probeDurationNs: parseFloat($("probe-duration").value),
        adaptiveRule: $("adaptive-rule").value,
        objective: $("objective").value,
        kpis: {
          fidelity: parseFloat($("kpi-fidelity").textContent),
          latencyUs: parseFloat($("kpi-latency").textContent),
          backAction: parseFloat($("kpi-backaction").textContent),
          shotUsage: $("kpi-shots").textContent,
        },
        notes: $("session-notes").value || null,
        exportedAt: new Date().toISOString(),
      };

      if (fmt === "csv") {
        const keys = Object.keys(data);
        const flat = {
          ...data,
          kpi_fidelity: data.kpis.fidelity,
          kpi_latencyUs: data.kpis.latencyUs,
          kpi_backAction: data.kpis.backAction,
          kpi_shotUsage: data.kpis.shotUsage,
        };
        delete flat.kpis;
        const header = Object.keys(flat).join(",");
        const row = Object.values(flat)
          .map((v) =>
            typeof v === "string"
              ? '"' + v.replace(/"/g, '""') + '"'
              : String(v)
          )
          .join(",");
        return header + "
" + row + "
";
      }

      if (fmt === "notebook") {
        return (
          "# SynQc TDS snapshot
" +
          "snapshot = " +
          JSON.stringify(data, null, 2) +
          "

" +
          "# Use `snapshot` inside your Jupyter pipeline."
        );
      }

      // default JSON
      return JSON.stringify(data, null, 2);
    }

    // Generate simple session ID on load
    (function initSession() {
      const id = "synqc-" + Math.random().toString(36).slice(2, 8);
      $("session-id-tag").textContent = "Session ID: " + id;
      appendLog("Session initialized with ID " + id + ".");
    })();
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SynQc TDS · Control Panel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg-main: #050711;
      --bg-panel: #101320;
      --bg-panel-alt: #15192a;
      --accent: #4f9cff;
      --accent-soft: rgba(79, 156, 255, 0.15);
      --accent-strong: #ffcc4f;
      --danger: #ff5468;
      --border-subtle: #24283b;
      --text-main: #f5f5f7;
      --text-muted: #a4a7bd;
      --text-soft: #777a90;
      --radius-lg: 14px;
      --radius-md: 10px;
      --radius-pill: 999px;
      --shadow-soft: 0 18px 40px rgba(0, 0, 0, 0.45);
      --shadow-subtle: 0 0 0 1px rgba(255, 255, 255, 0.02);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #15193a 0, #050711 52%, #02030a 100%);
      color: var(--text-main);
      -webkit-font-smoothing: antialiased;
    }
    h1, h2, h3 { margin: 0; font-weight: 600; letter-spacing: 0.02em; }
    p { margin: 0; }

    header.app-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.25rem 1.75rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(12px);
      background: linear-gradient(to right, rgba(5, 7, 17, 0.96), rgba(8, 11, 30, 0.96));
      position: sticky;
      top: 0;
      z-index: 20;
    }
    .logo-block { display: flex; align-items: center; gap: 0.9rem; }
    .logo-dot {
      width: 32px; height: 32px; border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #ffffff, #4f9cff 40%, #050711 80%);
      box-shadow: 0 0 40px rgba(79, 156, 255, 0.8), 0 0 0 1px rgba(255, 255, 255, 0.12);
    }
    .logo-block h1 { font-size: 1.1rem; }
    .logo-block p { font-size: 0.78rem; color: var(--text-soft); margin-top: 0.1rem; }

    .session-info {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.2rem;
      font-size: 0.8rem;
      color: var(--text-muted);
    }
    .session-info span { color: var(--text-main); font-weight: 500; }
    .status-pill {
      padding: 0.2rem 0.7rem;
      border-radius: var(--radius-pill);
      background: var(--accent-soft);
      color: var(--accent);
      font-size: 0.72rem;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
    }
    .status-dot {
      width: 7px; height: 7px; border-radius: 50%;
      background: var(--accent); box-shadow: 0 0 7px rgba(79, 156, 255, 0.9);
    }

    #globalStatus {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 1.25rem;
      padding: 0.4rem 0.9rem;
      border-radius: var(--radius-pill);
      background: rgba(12, 16, 36, 0.96);
      border: 1px solid rgba(255, 255, 255, 0.08);
      color: var(--text-muted);
      font-size: 0.78rem;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease, transform 0.2s ease;
      max-width: 90vw;
      z-index: 40;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #globalStatus.visible { opacity: 1; transform: translateX(-50%) translateY(0); pointer-events: auto; }
    #globalStatus[data-level="ok"] { border-color: rgba(79, 156, 255, 0.6); color: #b9d7ff; }
    #globalStatus[data-level="error"] { border-color: rgba(255, 84, 104, 0.7); color: #ffc1cb; }
    #globalStatus[data-level="warn"] { border-color: rgba(255, 204, 79, 0.7); color: #ffe9b4; }

    main.app-grid {
      display: grid;
      grid-template-columns: minmax(260px, 280px) minmax(320px, 3fr) minmax(260px, 320px);
      grid-auto-rows: minmax(160px, auto);
      gap: 1rem;
      padding: 1rem 1.5rem 2.5rem;
    }

    .panel {
      background: radial-gradient(circle at top left, #1c2140 0, #101320 42%, #070816 100%);
      border-radius: var(--radius-lg);
      padding: 0.9rem 1rem 1rem;
      box-shadow: var(--shadow-soft), var(--shadow-subtle);
      border: 1px solid rgba(255, 255, 255, 0.04);
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
    }
    .panel:nth-of-type(1) { grid-row: span 2; }
    .panel.kpi-panel { grid-column: 2 / 4; }
    .panel.log-panel { grid-column: 1 / 3; }
    .panel.export-panel { grid-column: 3 / 4; }

    .panel h2 { font-size: 0.95rem; margin-bottom: 0.15rem; }
    .panel h3 { font-size: 0.85rem; color: var(--text-muted); margin-top: 0.4rem; }
    label {
      font-size: 0.78rem;
      color: var(--text-muted);
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      margin-bottom: 0.3rem;
    }
    input[type="text"],
    input[type="number"],
    select,
    textarea {
      background: rgba(7, 10, 22, 0.9);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.05);
      padding: 0.45rem 0.55rem;
      color: var(--text-main);
      font-size: 0.8rem;
      outline: none;
      transition: border 0.15s ease, background 0.15s ease, box-shadow 0.15s ease;
    }
    input[type="text"]:focus,
    input[type="number"]:focus,
    select:focus,
    textarea:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(79, 156, 255, 0.3);
      background: rgba(7, 10, 24, 1);
    }
    textarea {
      resize: vertical;
      min-height: 70px;
      max-height: 260px;
      line-height: 1.3;
    }

    input[type="range"] {
      width: 100%;
      -webkit-appearance: none;
      appearance: none;
      height: 4px;
      border-radius: 999px;
      background: linear-gradient(90deg, var(--accent) 0%, #38d996 60%, #ffcc4f 100%);
      outline: none;
      margin: 0.4rem 0;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px; height: 14px; border-radius: 50%;
      background: #ffffff;
      border: 2px solid var(--accent);
      box-shadow: 0 0 12px rgba(79, 156, 255, 0.7);
      cursor: pointer;
    }
    input[type="range"]::-moz-range-thumb {
      width: 14px; height: 14px; border-radius: 50%;
      background: #ffffff;
      border: 2px solid var(--accent);
      box-shadow: 0 0 12px rgba(79, 156, 255, 0.7);
      cursor: pointer;
    }
    .range-row { display: flex; align-items: center; gap: 0.4rem; }
    .range-value {
      font-size: 0.78rem;
      color: var(--text-muted);
      min-width: 3.2rem;
      text-align: right;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-top: 0.15rem;
    }
    button {
      border-radius: var(--radius-pill);
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(16, 21, 43, 0.85);
      color: var(--text-main);
      font-size: 0.78rem;
      padding: 0.38rem 0.8rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
      transition: background 0.15s ease, border 0.15s ease, transform 0.05s ease, box-shadow 0.15s ease;
      white-space: nowrap;
    }
    button.primary {
      background: linear-gradient(135deg, #4f9cff, #38d996);
      border-color: rgba(255, 255, 255, 0.18);
      color: #050711;
      font-weight: 600;
      box-shadow: 0 10px 25px rgba(79, 156, 255, 0.45);
    }
    button.danger {
      background: rgba(255, 84, 104, 0.06);
      border-color: rgba(255, 84, 104, 0.7);
      color: #ff8d9d;
    }
    button.small { font-size: 0.72rem; padding: 0.25rem 0.6rem; }
    button:disabled { opacity: 0.45; cursor: default; box-shadow: none; }
    button:not(:disabled):hover {
      background: rgba(30, 37, 74, 0.95);
      transform: translateY(-1px);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.5);
    }
    button.primary:not(:disabled):hover {
      background: linear-gradient(135deg, #63aaff, #4ee1a8);
      transform: translateY(-1px);
      box-shadow: 0 14px 30px rgba(79, 156, 255, 0.55);
    }
    button.danger:not(:disabled):hover {
      background: rgba(255, 84, 104, 0.12);
      transform: translateY(-1px);
    }
    button:active:not(:disabled) { transform: translateY(0); box-shadow: none; }

    .help-text { font-size: 0.72rem; color: var(--text-soft); }
    .session-list {
      margin-top: 0.3rem;
      border-radius: var(--radius-md);
      background: rgba(5, 7, 17, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.03);
      max-height: 190px;
      overflow: hidden auto;
      padding: 0.15rem;
    }
    .session-row {
      width: 100%;
      justify-content: space-between;
      background: transparent;
      border-radius: var(--radius-md);
      padding: 0.3rem 0.4rem;
      border: none;
      border-bottom: 1px solid rgba(255, 255, 255, 0.02);
      font-size: 0.75rem;
      color: var(--text-soft);
    }
    .session-row strong { color: var(--text-main); font-weight: 500; }
    .session-row:last-child { border-bottom: none; }
    .session-row.active { background: rgba(79, 156, 255, 0.12); color: var(--text-main); }
    .session-row:hover:not(.active) { background: rgba(255, 255, 255, 0.02); }
    .session-row-id {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.7rem;
    }
    .session-row-status { font-size: 0.7rem; color: var(--text-soft); margin-left: 0.3rem; }

    .grid-two {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.5rem;
    }
    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(120px, 1fr));
      gap: 0.55rem;
      margin-top: 0.35rem;
    }
    .kpi-card {
      background: radial-gradient(circle at top, #1c2140 0, #101320 60%, #070816 100%);
      border-radius: 12px;
      padding: 0.55rem 0.65rem;
      border: 1px solid rgba(255, 255, 255, 0.04);
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
      min-height: 72px;
    }
    .kpi-title {
      font-size: 0.76rem;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.4rem;
    }
    .badge {
      padding: 0.08rem 0.4rem;
      border-radius: 999px;
      background: #252a3d;
      color: var(--accent-strong);
      font-size: 0.65rem;
      white-space: nowrap;
    }
    .kpi-value { font-size: 1.1rem; font-weight: 600; margin-top: 0.1rem; }
    .kpi-sub { font-size: 0.72rem; color: var(--text-soft); }
    .kpi-sub.positive { color: #4ee1a8; }
    .kpi-sub.negative { color: #ff8d9d; }

    .log-output {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: rgba(5, 7, 17, 0.95);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.05);
      padding: 0.5rem 0.55rem;
      font-size: 0.72rem;
      color: #d0d3ea;
      max-height: 260px;
      overflow-y: auto;
      margin-top: 0.25rem;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .inline { display: inline-flex; align-items: center; gap: 0.25rem; }
    .inline input[type="checkbox"] { margin: 0; }

    .export-output {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.72rem;
      background: rgba(5, 7, 17, 0.95);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.05);
      margin-top: 0.35rem;
      padding: 0.45rem 0.55rem;
      min-height: 120px;
      max-height: 260px;
    }

    .run-info { font-size: 0.74rem; color: var(--text-soft); margin-top: 0.2rem; }
    .run-info code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.7rem;
      background: rgba(255, 255, 255, 0.04);
      padding: 0.1rem 0.35rem;
      border-radius: 999px;
    }

    @media (max-width: 1024px) {
      main.app-grid { grid-template-columns: 1fr; }
      .panel, .panel.kpi-panel, .panel.log-panel, .panel.export-panel { grid-column: auto; grid-row: auto; }
      .kpi-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
    @media (max-width: 640px) {
      header.app-header { flex-direction: column; align-items: flex-start; gap: 0.7rem; }
      .session-info { align-items: flex-start; }
      .kpi-grid { grid-template-columns: 1fr; }
      .session-list { max-height: 160px; }
    }
  </style>
</head>
<body>
  <header class="app-header">
    <div class="logo-block">
      <div class="logo-dot"></div>
      <div>
        <h1>SynQc Temporal Dynamics Series</h1>
        <p>Drive–Probe–Drive · Control Panel</p>
      </div>
    </div>
    <div class="session-info">
      <div>Mode: <span id="sessionModeLabel">Local Simulation</span></div>
      <div>Session: <span id="sessionId">—</span></div>
      <div>
        <span class="status-pill">
          <span class="status-dot"></span>
          <span id="sessionStatus">No session yet</span>
        </span>
      </div>
    </div>
  </header>

  <div id="globalStatus" data-level="ok">Ready.</div>

  <main class="app-grid">
    <!-- Left column -->
    <section class="panel">
      <h2>Backend & Session</h2>
      <label for="apiBase">
        API base URL
        <input id="apiBase" type="text" spellcheck="false" autocomplete="off"
               placeholder="http://localhost:8000/api/v1/synqc" />
      </label>
      <label for="apiKey">
        API key (optional)
        <input id="apiKey" type="text" spellcheck="false" autocomplete="off"
               placeholder="X-API-Key value" />
      </label>
      <p class="help-text">
        Backend can enforce <code>X-API-Key</code> for multi-user labs.
      </p>
      <div class="button-row">
        <button id="btnHealth" class="small">Ping backend</button>
        <button id="btnRefreshSessions" class="small">Refresh sessions</button>
      </div>

      <h3>Session lifecycle</h3>
      <div class="button-row">
        <button id="btnNewSession" class="primary small">New session</button>
        <button id="btnSaveSession" class="small">Save session</button>
      </div>
      <p class="help-text">
        New session creates a fresh ID. Save updates the active session’s config.
      </p>

      <h3>Sessions on disk</h3>
      <div id="sessionList" class="session-list">
        <p class="help-text" style="padding:0.3rem 0.4rem;">
          No sessions yet. Press “New session”.
        </p>
      </div>

      <h2>Hardware stack</h2>
      <label for="hardwareTarget">
        Provider
        <select id="hardwareTarget">
          <option value="sim-local">Local simulator (CPU)</option>
          <option value="ibm-qpu">IBM Quantum QPU</option>
          <option value="aws-braket">AWS Braket</option>
          <option value="ionq">IonQ</option>
          <option value="classical-only">Classical lab hardware only</option>
        </select>
      </label>
      <label for="hardwarePreset">
        Hardware preset
        <select id="hardwarePreset">
          <option value="transmon-default">Transmon default · 5–27q</option>
          <option value="fluxonium-pilot">Fluxonium pilot · 2–5q</option>
          <option value="ion-chain">Trapped-ion chain · 11–32q</option>
          <option value="neutral-atom">Neutral atom array · 100+ sites</option>
        </select>
      </label>

      <h2>Notes</h2>
      <label for="notes">
        Session / run annotation
        <textarea id="notes" placeholder="Optional annotation for this session…"></textarea>
      </label>
    </section>

    <!-- Middle: config + run -->
    <section class="panel">
      <h2>Drive–Probe–Drive configuration</h2>
      <div class="grid-two">
        <label for="driveEnvelope">
          Drive envelope
          <select id="driveEnvelope">
            <option value="gaussian">Gaussian</option>
            <option value="square">Square</option>
            <option value="drag">DRAG</option>
            <option value="cosine">Cosine flat-top</option>
          </select>
        </label>
        <label for="adaptiveRule">
          Adaptive rule
          <select id="adaptiveRule">
            <option value="none">None (fixed)</option>
            <option value="kalman">Kalman update</option>
            <option value="bayes">Bayesian branching</option>
            <option value="rl">RL controller</option>
          </select>
        </label>
      </div>

      <label>
        Probe strength (ε)
        <div class="range-row">
          <input id="probeStrength" type="range" min="0" max="1" step="0.01" value="0.2" />
          <div class="range-value"><span id="probeStrengthValue">0.200</span></div>
        </div>
      </label>

      <label>
        Probe duration (τₚ, ns)
        <div class="range-row">
          <input id="probeDuration" type="range" min="5" max="5000" step="5" value="120" />
          <div class="range-value"><span id="probeDurationValue">120</span> ns</div>
        </div>
      </label>

      <label for="objective">
        Objective
        <select id="objective">
          <option value="maximize-fidelity">Maximize fidelity</option>
          <option value="minimize-latency">Minimize latency</option>
          <option value="info-vs-damage">Info vs back-action</option>
          <option value="stability-window">Stability over time</option>
        </select>
      </label>

      <h3>Run control</h3>
      <div class="button-row">
        <button id="btnDryRun" class="small">Dry-run (no hardware)</button>
        <button id="btnLaunchRun" class="primary small">Launch run</button>
        <button id="btnKillRun" class="danger small">Kill switch</button>
      </div>
      <p class="help-text">
        Backend maps these to <code>/sessions/{id}/run</code> (mode=<code>run</code> or <code>dryrun</code>)
        and <code>/sessions/{id}/kill</code>.
      </p>
      <div id="lastRunInfo" class="run-info">
        No runs yet.
      </div>
    </section>

    <!-- Right: KPIs -->
    <section class="panel kpi-panel">
      <h2>Live KPIs</h2>
      <div class="kpi-grid">
        <div class="kpi-card">
          <div class="kpi-title">
            <span>DPD fidelity</span>
            <span class="badge">target ≥ 0.975</span>
          </div>
          <div id="kpiFidelity" class="kpi-value">—</div>
          <div id="kpiFidelityDelta" class="kpi-sub">Awaiting run…</div>
        </div>
        <div class="kpi-card">
          <div class="kpi-title">
            <span>Latency (µs)</span>
            <span class="badge">loop end-to-end</span>
          </div>
          <div id="kpiLatency" class="kpi-value">—</div>
          <div id="kpiLatencyDelta" class="kpi-sub">Awaiting run…</div>
        </div>
        <div class="kpi-card">
          <div class="kpi-title">
            <span>Back-action</span>
            <span class="badge">info vs damage</span>
          </div>
          <div id="kpiBackaction" class="kpi-value">—</div>
          <div id="kpiBackactionHint" class="kpi-sub">Awaiting run…</div>
        </div>
        <div class="kpi-card">
          <div class="kpi-title">
            <span>Shot budget</span>
            <span class="badge">used / limit</span>
          </div>
          <div id="kpiShots" class="kpi-value">—</div>
          <div id="kpiShotsFraction" class="kpi-sub">No consumption yet.</div>
        </div>
      </div>
    </section>

    <!-- Logs -->
    <section class="panel log-panel">
      <h2>Run log</h2>
      <p class="help-text">
        Backed by <code>/sessions/{id}/logs</code>.
      </p>
      <div class="button-row">
        <button id="btnRefreshLogs" class="small">Refresh log</button>
        <button id="btnClearLogs" class="small">Clear log</button>
        <label class="inline">
          <input id="autoRefreshLogs" type="checkbox" />
          <span class="help-text">Auto-refresh (3s)</span>
        </label>
      </div>
      <pre id="logsContent" class="log-output">No logs yet.</pre>
    </section>

    <!-- Export -->
    <section class="panel export-panel">
      <h2>Export</h2>
      <p class="help-text">
        Uses <code>/sessions/{id}/export?format=…</code>.
      </p>
      <label for="exportFormat">
        Format
        <select id="exportFormat">
          <option value="json">JSON</option>
          <option value="csv">CSV</option>
          <option value="notebook">Notebook cell payload</option>
        </select>
      </label>
      <div class="button-row">
        <button id="btnExport" class="small">Export snapshot</button>
      </div>
      <textarea id="exportOutput" class="export-output" readonly spellcheck="false">
Waiting for export…
      </textarea>
    </section>
  </main>

  <script>
    (function () {
      const TARGET_FIDELITY = 0.975;
      const state = {
        apiBase: "",
        apiKey: "",
        health: null,
        session: null,
        lastRun: null,
        sessionsList: [],
        logs: [],
        exportFormat: "json",
        autosaveTimer: null,
        logTimer: null,
        statusTimer: null,
      };

      document.addEventListener("DOMContentLoaded", init);

      function init() {
        const apiBaseInput = document.getElementById("apiBase");
        const apiKeyInput = document.getElementById("apiKey");

        let defaultBase = "";
        try {
          const origin = window.location.origin;
          if (origin && origin !== "null" && origin !== "file://") {
            defaultBase = origin.replace(/\/+$/, "") + "/api/v1/synqc";
          }
        } catch (e) {}

        if (!defaultBase) defaultBase = "http://localhost:8000/api/v1/synqc";
        apiBaseInput.value = defaultBase;
        state.apiBase = defaultBase;

        apiBaseInput.addEventListener("change", (e) => {
          state.apiBase = e.target.value.trim();
          showStatus("API base set to " + state.apiBase, "ok");
        });
        apiKeyInput.addEventListener("change", (e) => {
          state.apiKey = e.target.value.trim();
          showStatus("API key updated", "ok");
        });

        wireControls();
        updateSessionHeader();
        updateKpis();
        updateExportOutput("Waiting for export…");

        pingHealth().catch(() => {});
        refreshSessionList().catch(() => {});
      }

      function wireControls() {
        document.getElementById("btnHealth").addEventListener("click", () => {
          pingHealth().catch(() => {});
        });
        document
          .getElementById("btnRefreshSessions")
          .addEventListener("click", () => refreshSessionList().catch(() => {}));
        document
          .getElementById("btnNewSession")
          .addEventListener("click", () => createNewSessionFromConfig().catch(() => {}));
        document
          .getElementById("btnSaveSession")
          .addEventListener("click", () => saveSessionConfig().catch(() => {}));

        ["hardwareTarget", "hardwarePreset", "driveEnvelope", "adaptiveRule", "objective"].forEach(
          (id) => document.getElementById(id).addEventListener("change", scheduleAutosave)
        );
        document.getElementById("notes").addEventListener("change", scheduleAutosave);

        const probeStrength = document.getElementById("probeStrength");
        const probeDuration = document.getElementById("probeDuration");
        probeStrength.addEventListener("input", () =>
          updateProbeStrengthDisplay(parseFloat(probeStrength.value))
        );
        probeStrength.addEventListener("change", scheduleAutosave);
        probeDuration.addEventListener("input", () =>
          updateProbeDurationDisplay(parseInt(probeDuration.value, 10))
        );
        probeDuration.addEventListener("change", scheduleAutosave);
        updateProbeStrengthDisplay(parseFloat(probeStrength.value));
        updateProbeDurationDisplay(parseInt(probeDuration.value, 10));

        document
          .getElementById("btnDryRun")
          .addEventListener("click", () => launchRun("dryrun").catch(() => {}));
        document
          .getElementById("btnLaunchRun")
          .addEventListener("click", () => launchRun("run").catch(() => {}));
        document
          .getElementById("btnKillRun")
          .addEventListener("click", () => killRun().catch(() => {}));

        document
          .getElementById("btnRefreshLogs")
          .addEventListener("click", () => refreshLogs().catch(() => {}));
        document
          .getElementById("btnClearLogs")
          .addEventListener("click", () => clearLogs().catch(() => {}));
        document
          .getElementById("autoRefreshLogs")
          .addEventListener("change", (e) => setAutoRefreshLogs(e.target.checked));

        const exportFormatSelect = document.getElementById("exportFormat");
        exportFormatSelect.addEventListener("change", (e) => {
          state.exportFormat = e.target.value;
        });
        document
          .getElementById("btnExport")
          .addEventListener("click", () => exportSnapshot().catch(() => {}));
      }

      function showStatus(message, level) {
        const bar = document.getElementById("globalStatus");
        bar.textContent = message;
        bar.setAttribute("data-level", level || "ok");
        bar.classList.add("visible");
        if (state.statusTimer) clearTimeout(state.statusTimer);
        state.statusTimer = setTimeout(() => bar.classList.remove("visible"), 4500);
      }

      function apiFetch(path, options) {
        const base = (state.apiBase || "").replace(/\/+$/, "");
        if (!base) return Promise.reject(new Error("API base URL is empty."));
        const url = base + path;
        const opts = options || {};
        const headers = opts.headers || {};
        if (opts.body && !("Content-Type" in headers)) {
          headers["Content-Type"] = "application/json";
        }
        if (state.apiKey) {
          headers["X-API-Key"] = state.apiKey;
        }
        opts.headers = headers;

        return fetch(url, opts).then((res) => {
          const ct = res.headers.get("content-type") || "";
          if (!res.ok) {
            if (ct.includes("application/json")) {
              return res.json().then((data) => {
                const detail = data && data.detail ? data.detail : res.statusText;
                throw new Error("HTTP " + res.status + ": " + detail);
              });
            }
            throw new Error("HTTP " + res.status + " for " + path);
          }
          if (ct.includes("application/json")) return res.json();
          return res.text();
        });
      }

      function pingHealth() {
        return apiFetch("/health")
          .then((data) => {
            state.health = data;
            showStatus(
              "Backend healthy (v" + data.version + ") @ " + (data.api_prefix || state.apiBase),
              "ok"
            );
          })
          .catch((err) => {
            showStatus("Health check failed: " + err.message, "error");
            throw err;
          });
      }

      function scheduleAutosave() {
        if (state.autosaveTimer) clearTimeout(state.autosaveTimer);
        state.autosaveTimer = setTimeout(() => saveSessionConfig().catch(() => {}), 600);
      }

      function buildConfigFromForm() {
        return {
          hardware_target: document.getElementById("hardwareTarget").value,
          hardware_preset: document.getElementById("hardwarePreset").value,
          drive_envelope: document.getElementById("driveEnvelope").value,
          probe_strength: parseFloat(document.getElementById("probeStrength").value),
          probe_duration_ns: parseInt(document.getElementById("probeDuration").value, 10),
          adaptive_rule: document.getElementById("adaptiveRule").value,
          objective: document.getElementById("objective").value,
          notes: document.getElementById("notes").value || null,
        };
      }

      function applyConfigToForm(cfg) {
        if (!cfg) return;
        const set = (id, val) => {
          const el = document.getElementById(id);
          if (val !== undefined && el) el.value = val;
        };
        set("hardwareTarget", cfg.hardware_target);
        set("hardwarePreset", cfg.hardware_preset);
        set("driveEnvelope", cfg.drive_envelope);
        set("adaptiveRule", cfg.adaptive_rule);
        set("objective", cfg.objective);

        if (typeof cfg.probe_strength === "number") {
          const s = document.getElementById("probeStrength");
          s.value = cfg.probe_strength;
          updateProbeStrengthDisplay(cfg.probe_strength);
        }
        if (typeof cfg.probe_duration_ns === "number") {
          const d = document.getElementById("probeDuration");
          d.value = cfg.probe_duration_ns;
          updateProbeDurationDisplay(cfg.probe_duration_ns);
        }
        document.getElementById("notes").value = cfg.notes || "";
      }

      function updateProbeStrengthDisplay(v) {
        if (!isFinite(v)) v = 0;
        document.getElementById("probeStrengthValue").textContent = v.toFixed(3);
      }
      function updateProbeDurationDisplay(v) {
        if (!isFinite(v)) v = 0;
        document.getElementById("probeDurationValue").textContent = v.toFixed(0);
      }

      function createNewSessionFromConfig() {
        const cfg = buildConfigFromForm();
        return apiFetch("/sessions", {
          method: "POST",
          body: JSON.stringify({ session_id: null, config: cfg }),
        })
          .then((session) => {
            state.session = session;
            state.lastRun = null;
            updateSessionHeader();
            updateKpis();
            showStatus("Created session " + session.session_id, "ok");
            return refreshSessionList();
          })
          .catch((err) => {
            showStatus("Failed to create session: " + err.message, "error");
            throw err;
          });
      }

      function saveSessionConfig() {
        const cfg = buildConfigFromForm();
        const sessionId = state.session && state.session.session_id ? state.session.session_id : null;
        return apiFetch("/sessions", {
          method: "POST",
          body: JSON.stringify({ session_id: sessionId, config: cfg }),
        })
          .then((session) => {
            state.session = session;
            updateSessionHeader();
            updateKpis();
            showStatus("Saved configuration to " + session.session_id, "ok");
            return refreshSessionList();
          })
          .catch((err) => {
            showStatus("Failed to save config: " + err.message, "error");
            throw err;
          });
      }

      function refreshSessionList() {
        return apiFetch("/sessions")
          .then((sessions) => {
            state.sessionsList = Array.isArray(sessions) ? sessions : [];
            renderSessionList();
          })
          .catch((err) => {
            showStatus("Failed to list sessions: " + err.message, "error");
            throw err;
          });
      }

      function renderSessionList() {
        const container = document.getElementById("sessionList");
        container.innerHTML = "";
        if (!state.sessionsList.length) {
          const p = document.createElement("p");
          p.className = "help-text";
          p.style.padding = "0.3rem 0.4rem";
          p.textContent = "No sessions on disk yet.";
          container.appendChild(p);
          return;
        }
        state.sessionsList
          .slice()
          .sort(
            (a, b) =>
              new Date(b.last_updated_at || b.created_at || 0).getTime() -
              new Date(a.last_updated_at || a.created_at || 0).getTime()
          )
          .forEach((session) => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "session-row";

            const idSpan = document.createElement("span");
            idSpan.className = "session-row-id";
            idSpan.textContent = session.session_id;

            const statusSpan = document.createElement("span");
            statusSpan.className = "session-row-status";
            statusSpan.textContent = session.status_text || session.status || "";

            btn.appendChild(idSpan);
            btn.appendChild(statusSpan);

            const active =
              state.session && state.session.session_id === session.session_id;
            if (active) btn.classList.add("active");

            btn.addEventListener("click", () => loadSession(session.session_id).catch(() => {}));
            container.appendChild(btn);
          });
      }

      function loadSession(sessionId) {
        return apiFetch("/sessions/" + encodeURIComponent(sessionId))
          .then((session) => {
            state.session = session;
            state.lastRun = null;
            applyConfigToForm(session.config);
            updateSessionHeader();
            updateKpis();
            showStatus("Loaded session " + sessionId, "ok");
            renderSessionList();
            return refreshLogs();
          })
          .catch((err) => {
            showStatus("Failed to load session: " + err.message, "error");
            throw err;
          });
      }

      function updateSessionHeader() {
        const modeEl = document.getElementById("sessionModeLabel");
        const idEl = document.getElementById("sessionId");
        const statusEl = document.getElementById("sessionStatus");
        if (!state.session) {
          modeEl.textContent = "Local Simulation";
          idEl.textContent = "—";
          statusEl.textContent = "No session yet";
          return;
        }
        modeEl.textContent = state.session.mode_label || "Session";
        idEl.textContent = state.session.session_id;
        statusEl.textContent = state.session.status_text || state.session.status || "";
      }

      function updateKpis() {
        const k = state.session ? state.session.last_kpis : null;
        const fidelityEl = document.getElementById("kpiFidelity");
        const fidelityDeltaEl = document.getElementById("kpiFidelityDelta");
        const latencyEl = document.getElementById("kpiLatency");
        const latencyDeltaEl = document.getElementById("kpiLatencyDelta");
        const backEl = document.getElementById("kpiBackaction");
        const backHintEl = document.getElementById("kpiBackactionHint");
        const shotsEl = document.getElementById("kpiShots");
        const shotsFracEl = document.getElementById("kpiShotsFraction");

        fidelityDeltaEl.classList.remove("positive", "negative");
        latencyDeltaEl.classList.remove("positive", "negative");

        if (!k) {
          fidelityEl.textContent = "—";
          fidelityDeltaEl.textContent = "Awaiting run…";
          latencyEl.textContent = "—";
          latencyDeltaEl.textContent = "Awaiting run…";
          backEl.textContent = "—";
          backHintEl.textContent = "Awaiting run…";
          shotsEl.textContent = "—";
          shotsFracEl.textContent = "No consumption yet.";
          return;
        }

        const fid = Number(k.fidelity);
        const lat = Number(k.latency_us);
        const back = Number(k.backaction);
        const shotsUsed = Number(k.shots_used);
        const shotLimit = Number(k.shot_limit);
        const frac =
          typeof k.shots_used_fraction === "number"
            ? k.shots_used_fraction
            : shotLimit > 0
            ? Math.min(1, Math.max(0, shotsUsed / shotLimit))
            : 0;

        fidelityEl.textContent = fid.toFixed(3);
        const delta = fid - TARGET_FIDELITY;
        if (Math.abs(delta) < 1e-4) {
          fidelityDeltaEl.textContent = "At target";
        } else if (delta > 0) {
          fidelityDeltaEl.textContent = "+" + delta.toFixed(3) + " vs target";
          fidelityDeltaEl.classList.add("positive");
        } else {
          fidelityDeltaEl.textContent = delta.toFixed(3) + " vs target";
          fidelityDeltaEl.classList.add("negative");
        }

        latencyEl.textContent = lat.toFixed(1);
        if (lat < 20) {
          latencyDeltaEl.textContent = "Fast loop";
          latencyDeltaEl.classList.add("positive");
        } else if (lat > 80) {
          latencyDeltaEl.textContent = "High latency";
          latencyDeltaEl.classList.add("negative");
        } else {
          latencyDeltaEl.textContent = "Moderate latency";
        }

        backEl.textContent = back.toFixed(3);
        if (back < 0.25) {
          backHintEl.textContent = "Back-action acceptable";
          backHintEl.classList.add("positive");
        } else if (back > 0.6) {
          backHintEl.textContent = "Back-action heavy – ease ε";
          backHintEl.classList.add("negative");
        } else {
          backHintEl.textContent = "Balanced regime";
        }

        shotsEl.textContent = formatShots(shotsUsed) + " / " + formatShots(shotLimit);
        shotsFracEl.textContent = (frac * 100).toFixed(1) + "% consumed";
      }

      function formatShots(n) {
        if (!isFinite(n) || n < 0) return "0";
        if (n >= 1_000_000) return (n / 1_000_000).toFixed(1) + "M";
        if (n >= 1_000) return (n / 1_000).toFixed(1) + "k";
        return String(Math.round(n));
      }

      function launchRun(mode) {
        if (!state.session || !state.session.session_id) {
          showStatus("Create or load a session first.", "warn");
          return Promise.resolve();
        }
        const sessionId = state.session.session_id;
        const payload = { mode: mode === "dryrun" ? "dryrun" : "run" };

        const runBtn = document.getElementById("btnLaunchRun");
        const dryBtn = document.getElementById("btnDryRun");
        runBtn.disabled = true;
        dryBtn.disabled = true;

        return apiFetch("/sessions/" + encodeURIComponent(sessionId) + "/run", {
          method: "POST",
          body: JSON.stringify(payload),
        })
          .then((resp) => {
            state.session = resp.session;
            state.lastRun = resp.run;
            updateSessionHeader();
            updateKpis();
            renderSessionList();
            updateLastRunInfo();
            showStatus(
              "Run " + resp.run.run_id + " completed (" + resp.run.mode + ")",
              "ok"
            );
            return refreshLogs();
          })
          .catch((err) => {
            showStatus("Run failed: " + err.message, "error");
            throw err;
          })
          .finally(() => {
            runBtn.disabled = false;
            dryBtn.disabled = false;
          });
      }

      function updateLastRunInfo() {
        const el = document.getElementById("lastRunInfo");
        const run = state.lastRun;
        if (!run) {
          el.textContent = "No runs yet.";
          return;
        }
        const ts = run.created_at || "";
        const modeLabel = run.mode === "dryrun" ? "dry-run" : "run";
        const k = run.kpis;
        let summary = "";
        if (k) {
          summary =
            " · fidelity=" +
            k.fidelity.toFixed(3) +
            ", latency=" +
            k.latency_us.toFixed(1) +
            "µs, back-action=" +
            k.backaction.toFixed(3) +
            ", shots=" +
            formatShots(k.shots_used) +
            "/" +
            formatShots(k.shot_limit);
        }
        el.innerHTML =
          "Last " +
          modeLabel +
          ' <code>' +
          run.run_id +
          "</code> @ " +
          ts +
          summary;
      }

      function killRun() {
        if (!state.session || !state.session.session_id) {
          showStatus("No active session to kill.", "warn");
          return Promise.resolve();
        }
        const sessionId = state.session.session_id;
        return apiFetch("/sessions/" + encodeURIComponent(sessionId) + "/kill", {
          method: "POST",
        })
          .then(() =>
            apiFetch("/sessions/" + encodeURIComponent(sessionId)).then((session) => {
              state.session = session;
              updateSessionHeader();
              showStatus("Kill switch pressed for " + sessionId, "ok");
              return refreshLogs();
            })
          )
          .catch((err) => {
            showStatus("Kill switch failed: " + err.message, "error");
            throw err;
          });
      }

      function refreshLogs() {
        if (!state.session || !state.session.session_id) {
          document.getElementById("logsContent").textContent = "No session loaded.";
          return Promise.resolve();
        }
        const sessionId = state.session.session_id;
        return apiFetch("/sessions/" + encodeURIComponent(sessionId) + "/logs?limit=200")
          .then((resp) => {
            const lines = resp && resp.lines ? resp.lines : [];
            state.logs = lines;
            renderLogs();
          })
          .catch((err) => {
            showStatus("Failed to fetch logs: " + err.message, "error");
            throw err;
          });
      }

      function renderLogs() {
        const pre = document.getElementById("logsContent");
        if (!state.logs.length) {
          pre.textContent = "No logs yet.";
          return;
        }
        pre.textContent = state.logs.join("\n");
      }

      function clearLogs() {
        if (!state.session || !state.session.session_id) {
          showStatus("No session loaded to clear logs.", "warn");
          return Promise.resolve();
        }
        const sessionId = state.session.session_id;
        return apiFetch("/sessions/" + encodeURIComponent(sessionId) + "/logs", {
          method: "DELETE",
        })
          .then(() => {
            showStatus("Logs cleared for " + sessionId, "ok");
            return refreshLogs();
          })
          .catch((err) => {
            showStatus("Failed to clear logs: " + err.message, "error");
            throw err;
          });
      }

      function setAutoRefreshLogs(enabled) {
        if (state.logTimer) {
          clearInterval(state.logTimer);
          state.logTimer = null;
        }
        if (!enabled) return;
        state.logTimer = setInterval(() => {
          if (!state.session || !state.session.session_id) return;
          refreshLogs().catch(() => {});
        }, 3000);
      }

      function exportSnapshot() {
        if (!state.session || !state.session.session_id) {
          showStatus("No session loaded for export.", "warn");
          return Promise.resolve();
        }
        const sessionId = state.session.session_id;
        const format = state.exportFormat || "json";
        const path =
          "/sessions/" +
          encodeURIComponent(sessionId) +
          "/export?format=" +
          encodeURIComponent(format);

        return apiFetch(path)
          .then((resp) => {
            if (!resp || typeof resp !== "object") {
              updateExportOutput(String(resp));
              showStatus("Export completed.", "ok");
              return;
            }
            if (resp.format === "json") {
              updateExportOutput(JSON.stringify(resp.payload, null, 2) + "\n");
            } else {
              updateExportOutput(String(resp.payload || ""));
            }
            showStatus("Exported snapshot as " + resp.format, "ok");
          })
          .catch((err) => {
            showStatus("Export failed: " + err.message, "error");
            throw err;
          });
      }

      function updateExportOutput(text) {
        const el = document.getElementById("exportOutput");
        el.value = text || "";
      }
    })();
  </script>
</body>
</html>
async function fetchQuickstartConfig() {
  const res = await fetch("http://localhost:8000/api/quickstart-config");
  if (!res.ok) {
    throw new Error("Failed to fetch SynQc quickstart config");
  }
  return await res.json(); // { sample_rate_hz, lo_frequency_hz, ..., pulses: [...] }
}

async function runSynQc(configOverride) {
  // Get default config from backend, then let UI tweak it
  const baseConfig = await fetchQuickstartConfig();
  const config = Object.assign({}, baseConfig, configOverride || {});

  const body = {
    config,
    num_iterations: 5,
    run_adaptive: true,
  };

  const res = await fetch("http://localhost:8000/api/run", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });

  if (!res.ok) {
    const text = await res.text();
    throw new Error("SynQc run failed: " + text);
  }

  const data = await res.json();
  // data.iteration = array of samples
  // data.adaptive  = array of per-iteration metrics or null

  console.log("Iteration trace:", data.iteration);
  console.log("Adaptive loop:", data.adaptive);

  // Now plug these into whatever plotting / KPI widgets that HTML has.
}
"""
hardware_backends.py

Hardware abstraction layer for SynQc TDS.

This isolates:
- Local simulation (for the UI and development)
- Real quantum providers (IBM, AWS Braket, IonQ)
- Classical-only lab hardware (FPGA/DAQ)
from the FastAPI app and session engine.

You plug it into your existing SynQcEngine so that
SynQcEngine only knows "call backend.run_experiment(config, session)".
"""

from __future__ import annotations

import math
import os
import time
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Any, Dict, Mapping, Optional

import numpy as np

# ---------------------------------------------------------------------------
# Shared limits (safety guards)
# ---------------------------------------------------------------------------

MAX_PROBE_STRENGTH: float = float(os.getenv("SYNQC_MAX_PROBE_STRENGTH", "0.5"))
MAX_PROBE_DURATION_NS: int = int(os.getenv("SYNQC_MAX_PROBE_DURATION_NS", "5000"))
MAX_SHOTS_PER_RUN: int = int(os.getenv("SYNQC_MAX_SHOTS_PER_RUN", "200_000"))


@dataclass
class SimKpis:
  """Simple dataclass so we don't tie to a particular Pydantic model here."""

  fidelity: float
  latency_us: float
  backaction: float
  shots_used: int
  shot_limit: int

  @property
  def shots_used_fraction(self) -> float:
    return min(1.0, self.shots_used / self.shot_limit) if self.shot_limit > 0 else 0.0


class HardwareBackend(ABC):
  """
  Contract for all hardware backends.

  cfg:  your existing RunConfiguration (Pydantic model on the backend).
  session: your existing SessionState instance.
  Returns: something that can be converted into your KpiBundle.
  """

  target_id: str  # e.g. "sim-local", "ibm-qpu", ...

  def __init__(self, target_id: str, name: str):
    self.target_id = target_id
    self.name = name

  @abstractmethod
  def run_experiment(self, cfg: Any, session: Any, *, dry_run: bool = False) -> SimKpis:
    """
    Execute (or simulate) a DPD experiment for the given configuration.

    This is where:
      - you call Qiskit / Braket / IonQ / DAQ drivers
      - OR you call a local simulator
      - you enforce hardware safety limits
    """
    raise NotImplementedError


# ---------------------------------------------------------------------------
# Local simulation backend
# ---------------------------------------------------------------------------


class LocalSimBackend(HardwareBackend):
  """
  High-level "sane" simulator that mimics tradeoffs:

  - Higher probe_strength -> more information but more back-action.
  - Longer probe_duration_ns -> higher latency and back-action, some fidelity changes.
  - Different objectives tweak effective scaling.

  This is where the previous SynQcEngine._simulate_kpis logic lives.
  """

  def __init__(self) -> None:
    super().__init__(target_id="sim-local", name="Local simulator")
    self._rng = np.random.default_rng()

  def run_experiment(self, cfg: Any, session: Any, *, dry_run: bool = False) -> SimKpis:
    # Safety clamps
    eps = float(cfg.probe_strength)
    tau_ns = int(cfg.probe_duration_ns)

    if eps < 0:
      eps = 0.0
    if eps > MAX_PROBE_STRENGTH:
      # Hard fail instead of silently clamping, safer for real hardware.
      raise ValueError(
        f"probe_strength={cfg.probe_strength} exceeds limit "
        f"{MAX_PROBE_STRENGTH}. Refusing to run."
      )
    if tau_ns < 1:
      tau_ns = 1
    if tau_ns > MAX_PROBE_DURATION_NS:
      raise ValueError(
        f"probe_duration_ns={cfg.probe_duration_ns} exceeds limit "
        f"{MAX_PROBE_DURATION_NS}. Refusing to run."
      )

    # Basic "difficulty" factor by objective
    objective = getattr(cfg, "objective", "maximize-fidelity")
    obj_weight = {
      "maximize-fidelity": 1.0,
      "minimize-latency": 0.9,
      "info-vs-damage": 0.95,
      "stability-window": 0.97,
    }.get(objective, 1.0)

    # "Hardware" scaling: transmon vs trapped-ion vs neutral atoms etc.
    preset = getattr(cfg, "hardware_preset", "transmon-default")
    hw_factor = {
      "transmon-default": 1.0,
      "fluxonium-pilot": 0.96,
      "ion-chain": 0.93,
      "neutral-atom": 0.9,
    }.get(preset, 1.0)

    # Latency in microseconds (toy model)
    base_latency_us = 15.0
    latency_us = base_latency_us + (tau_ns / 500.0) + 20.0 * eps
    latency_us *= hw_factor

    # Back-action grows with eps and tau (but saturates)
    backaction = 1.0 - math.exp(-eps * tau_ns / 1000.0)
    backaction = min(backaction, 1.0)

    # Fidelity: high at small eps and moderate tau; falls if too aggressive
    sweet_eps = 0.18
    sweet_tau = 300.0
    eps_term = math.exp(-((eps - sweet_eps) ** 2) / (2 * 0.06**2))
    tau_term = math.exp(-((tau_ns - sweet_tau) ** 2) / (2 * 280.0**2))
    fidelity_mean = 0.80 + 0.15 * eps_term * tau_term
    fidelity_mean *= obj_weight
    fidelity_mean *= hw_factor

    # Some stochasticity
    jitter = float(self._rng.normal(0.0, 0.004))
    fidelity = max(0.0, min(0.9999, fidelity_mean + jitter))

    # Shot accounting
    default_shots = 20_000
    shot_limit = min(MAX_SHOTS_PER_RUN, int(getattr(session, "shot_limit", default_shots)))
    shots_used = min(shot_limit, int(default_shots * (0.6 + 0.8 * eps)))

    # Optionally be nicer for dry-run (short latency, no consumption)
    if dry_run:
      latency_us *= 0.3
      shots_used = 0

    return SimKpis(
      fidelity=fidelity,
      latency_us=latency_us,
      backaction=backaction,
      shots_used=shots_used,
      shot_limit=shot_limit,
    )


# ---------------------------------------------------------------------------
# IBM Quantum QPU backend (skeleton)
# ---------------------------------------------------------------------------


class IbmQpuBackend(HardwareBackend):
  """
  Skeleton integration for IBM QPU.

  You configure:
    - IBM_QUANTUM_CHANNEL (optional)
    - IBM_QUANTUM_BACKEND_NAME
    - IBM_QUANTUM_TOKEN (or use qiskit-ibm-runtime's default account config)

  This class intentionally imports qiskit lazily so the file can be imported
  even if qiskit is not installed (e.g. purely-sim local dev).
  """

  def __init__(self) -> None:
    super().__init__(target_id="ibm-qpu", name="IBM Quantum")

  def run_experiment(self, cfg: Any, session: Any, *, dry_run: bool = False) -> SimKpis:
    if dry_run:
      # Delegate to local sim for UI-only dry-runs.
      return LocalSimBackend().run_experiment(cfg, session, dry_run=True)

    try:
      from qiskit_ibm_runtime import QiskitRuntimeService
    except ImportError as exc:
      raise RuntimeError(
        "qiskit-ibm-runtime is not installed. "
        "Install with `pip install qiskit-ibm-runtime`."
      ) from exc

    backend_name = os.getenv("IBM_QUANTUM_BACKEND_NAME", "").strip()
    if not backend_name:
      raise RuntimeError("IBM_QUANTUM_BACKEND_NAME not set")

    service = QiskitRuntimeService()
    backend = service.backend(backend_name)

    # TODO: translate cfg into a circuit and a schedule.
    # This is where you call assemble/run/etc. For now we refuse to run
    # to avoid giving you fake QPU results.
    raise NotImplementedError(
      "IbmQpuBackend.run_experiment: implement circuit compilation + execution "
      "for your specific DPD experiment."
    )


# ---------------------------------------------------------------------------
# AWS Braket backend (skeleton)
# ---------------------------------------------------------------------------


class AwsBraketBackend(HardwareBackend):
  """
  Skeleton integration for AWS Braket.

  Configure AWS creds and set:
    - BRAKET_DEVICE_ARN
  """

  def __init__(self) -> None:
    super().__init__(target_id="aws-braket", name="AWS Braket")

  def run_experiment(self, cfg: Any, session: Any, *, dry_run: bool = False) -> SimKpis:
    if dry_run:
      return LocalSimBackend().run_experiment(cfg, session, dry_run=True)

    try:
      from braket.aws import AwsDevice
    except ImportError as exc:
      raise RuntimeError(
        "amazon-braket-sdk is not installed. "
        "Install with `pip install amazon-braket-sdk`."
      ) from exc

    device_arn = os.getenv("BRAKET_DEVICE_ARN", "").strip()
    if not device_arn:
      raise RuntimeError("BRAKET_DEVICE_ARN not set")

    device = AwsDevice(device_arn)

    # TODO: translate cfg into a Braket circuit/task.
    raise NotImplementedError(
      "AwsBraketBackend.run_experiment: implement task creation + result handling."
    )


# ---------------------------------------------------------------------------
# IonQ backend (skeleton)
# ---------------------------------------------------------------------------


class IonqBackend(HardwareBackend):
  """
  Skeleton integration for IonQ.

  Depending on whether you use IonQ directly or via a provider,
  you might use:
    - ionq python SDK
    - qiskit-ionq
  """

  def __init__(self) -> None:
    super().__init__(target_id="ionq", name="IonQ")

  def run_experiment(self, cfg: Any, session: Any, *, dry_run: bool = False) -> SimKpis:
    if dry_run:
      return LocalSimBackend().run_experiment(cfg, session, dry_run=True)

    # Don’t pretend to know your IonQ integration – keep this as an explicit TODO.
    raise NotImplementedError(
      "IonqBackend.run_experiment: wire this up to your IonQ integration "
      "(native SDK or qiskit-ionq)."
    )


# ---------------------------------------------------------------------------
# Classical-only backend (FPGA / DAQ)
# ---------------------------------------------------------------------------


class ClassicalFpgaBackend(HardwareBackend):
  """
  Skeleton integration for classical-only lab hardware
  (FPGA controllers, AWGs, digitizers, DAQs).

  Expected pattern:
    - you have a local driver library (pyvisa / custom TCP / vendor API)
    - you translate cfg into pulse programs
    - you stream those to hardware, read back metrics, produce KPIs
  """

  def __init__(self) -> None:
    super().__init__(target_id="classical-only", name="Classical FPGA/DAQ")

  def run_experiment(self, cfg: Any, session: Any, *, dry_run: bool = False) -> SimKpis:
    if dry_run:
      # For purely classical rigs, dry-run usually means "compile only".
      return LocalSimBackend().run_experiment(cfg, session, dry_run=True)

    # This is intentionally left as an explicit integration point.
    raise NotImplementedError(
      "ClassicalFpgaBackend.run_experiment: integrate with your FPGA/DAQ driver."
    )


# ---------------------------------------------------------------------------
# Registry
# ---------------------------------------------------------------------------

_BACKENDS: Dict[str, HardwareBackend] = {
  "sim-local": LocalSimBackend(),
  "ibm-qpu": IbmQpuBackend(),
  "aws-braket": AwsBraketBackend(),
  "ionq": IonqBackend(),
  "classical-only": ClassicalFpgaBackend(),
}


def get_backend(target_id: str) -> HardwareBackend:
  """
  Resolve hardware_target from RunConfiguration -> backend instance.
  """
  if target_id not in _BACKENDS:
    raise KeyError(f"Unknown hardware_target={target_id!r}")
  return _BACKENDS[target_id]

"""
SynQc Temporal Dynamics Series — Super Backend

Single-file backend that matches the "SynQc Temporal Dynamics Series —
Control Panel v0.2" HTML controller.

Features
--------
- Session model that mirrors the front-end controls:
  * hardware target & preset
  * drive envelope
  * probe strength & duration
  * adaptive rule
  * objective
  * free-form notes

- Simulation engine that produces physically-inspired KPIs:
  * DPD Fidelity (0–1)
  * Loop latency (microseconds)
  * Probe back-action (0–1 scale)
  * Shot budget usage (out of a configurable limit)

- Persistent state:
  * Sessions and runs stored under SYNQC_STATE_DIR (JSON files)
  * Shot budget tracked per session
  * Logs kept per session

- Export endpoint that replicates the front-end snapshot payload:
  * JSON, CSV, or "notebook" (a ready-to-paste Python cell)

Tech stack
----------
- Python 3.10+
- FastAPI
- Uvicorn
- Pydantic v2+
- python-dotenv
- NumPy

To run
------
1. Install dependencies (example):

   pip install fastapi uvicorn[standard] pydantic>=2.7.0 python-dotenv numpy

2. Optional: create a .env next to this file with:

   SYNQC_API_PREFIX=/api/v1/synqc
   SYNQC_STATE_DIR=./synqc_state
   SYNQC_ALLOWED_ORIGINS=*

   SYNQC_HOST=0.0.0.0
   SYNQC_PORT=8000

3. Start server:

   uvicorn synqc_tds_super_backend:app --host 0.0.0.0 --port 8000 --reload
"""

from __future__ import annotations

import json
import math
import os
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional, Literal, Any

import numpy as np
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field, field_validator


# -------------------------------------------------------------------------
# Environment & configuration
# -------------------------------------------------------------------------


load_dotenv()


def _env(name: str, default: str) -> str:
    return os.getenv(name, default)


API_PREFIX = _env("SYNQC_API_PREFIX", "/api/v1/synqc").rstrip("/")
STATE_DIR = Path(_env("SYNQC_STATE_DIR", "./synqc_state")).resolve()
ALLOWED_ORIGINS_RAW = _env("SYNQC_ALLOWED_ORIGINS", "*")
ALLOWED_ORIGINS = [o.strip() for o in ALLOWED_ORIGINS_RAW.split(",") if o.strip()] or ["*"]

# Defaults used by the UI
DEFAULT_SHOT_LIMIT = 50_000


# -------------------------------------------------------------------------
# Enumerations that mirror the HTML controller
# -------------------------------------------------------------------------


class HardwareTarget(str, Enum):
    SIM_LOCAL = "sim-local"
    IBM_QPU = "ibm-qpu"
    AWS_BRAKET = "aws-braket"
    IONQ = "ionq"
    CLASSICAL_ONLY = "classical-only"


class HardwarePreset(str, Enum):
    TRANSMON_DEFAULT = "transmon-default"
    FLUXONIUM_PILOT = "fluxonium-pilot"
    ION_CHAIN = "ion-chain"
    NEUTRAL_ATOM = "neutral-atom"


class DriveEnvelope(str, Enum):
    GAUSSIAN = "gaussian"
    SQUARE = "square"
    DRAG = "drag"
    COSINE = "cosine"


class AdaptiveRule(str, Enum):
    NONE = "none"
    KALMAN = "kalman"
    BAYES = "bayes"
    RL = "rl"


class Objective(str, Enum):
    MAXIMIZE_FIDELITY = "maximize-fidelity"
    MINIMIZE_LATENCY = "minimize-latency"
    INFO_VS_DAMAGE = "info-vs-damage"
    STABILITY_WINDOW = "stability-window"


class RunMode(str, Enum):
    RUN = "run"
    DRYRUN = "dryrun"


class SessionStatus(str, Enum):
    IDLE = "idle"
    RUNNING = "running"
    TERMINATED = "terminated"
    ERROR = "error"


# -------------------------------------------------------------------------
# Core configuration & KPI models
# -------------------------------------------------------------------------


class RunConfiguration(BaseModel):
    """
    Configuration that corresponds one-to-one with front-end controls.
    """

    hardware_target: HardwareTarget = Field(
        ..., description="Target provider selected in the sidebar."
    )
    hardware_preset: HardwarePreset = Field(
        ..., description="Hardware profile (e.g. transmon, fluxonium, ion chain)."
    )
    drive_envelope: DriveEnvelope = Field(
        ..., description="Drive envelope shape used in the DPD schedule."
    )
    probe_strength: float = Field(
        0.2,
        ge=0.0,
        le=1.0,
        description="Dimensionless probe strength ε (0–1).",
    )
    probe_duration_ns: int = Field(
        120,
        ge=5,
        le=5000,
        description="Probe duration τ_p in nanoseconds.",
    )
    adaptive_rule: AdaptiveRule = Field(
        AdaptiveRule.NONE,
        description="High-level controller class for adaptation.",
    )
    objective: Objective = Field(
        Objective.MAXIMIZE_FIDELITY,
        description="Primary objective for the loop.",
    )
    notes: Optional[str] = Field(
        None,
        description="Free-form annotation from the Notes panel.",
    )

    @field_validator("probe_strength")
    @classmethod
    def _strength_non_nan(cls, v: float) -> float:
        if math.isnan(v):
            return 0.2
        return v

    @field_validator("probe_duration_ns")
    @classmethod
    def _duration_reasonable(cls, v: int) -> int:
        if v <= 0:
            return 120
        return v


class KpiBundle(BaseModel):
    """
    KPIs that drive the 'Live KPIs' cards in the HTML controller.
    """

    fidelity: float = Field(..., description="DPD fidelity proxy (0–1).")
    latency_us: float = Field(..., description="End-to-end DPD loop latency (µs).")
    backaction: float = Field(
        ..., description="Probe back-action (0–1, where lower is better)."
    )
    shots_used: int = Field(..., description="Cumulative shots used in session.")
    shot_limit: int = Field(DEFAULT_SHOT_LIMIT, description="Shot budget limit.")
    # Server-computed convenience fields
    shots_used_fraction: float = Field(
        ..., description="shots_used / shot_limit, clipped to [0, 1]."
    )

    @classmethod
    def from_raw(
        cls,
        fidelity: float,
        latency_us: float,
        backaction: float,
        shots_used: int,
        shot_limit: int,
    ) -> "KpiBundle":
        frac = 0.0 if shot_limit <= 0 else min(1.0, max(0.0, shots_used / shot_limit))
        return cls(
            fidelity=float(fidelity),
            latency_us=float(latency_us),
            backaction=float(backaction),
            shots_used=int(shots_used),
            shot_limit=int(shot_limit),
            shots_used_fraction=frac,
        )


class RunRecord(BaseModel):
    """
    Complete record for one run (real or dry-run).
    """

    run_id: str
    session_id: str
    mode: RunMode
    config_snapshot: RunConfiguration
    created_at: datetime
    kpis: Optional[KpiBundle] = None
    # log messages attached only to this run
    events: List[str] = Field(default_factory=list)


class SessionState(BaseModel):
    """
    State for a control-panel session. This is what we persist between runs.
    """

    session_id: str
    created_at: datetime
    last_updated_at: datetime
    status: SessionStatus = SessionStatus.IDLE
    status_text: str = "Idle · no active run"
    mode_label: str = "Local Simulation"
    config: RunConfiguration
    last_run_id: Optional[str] = None
    shot_limit: int = DEFAULT_SHOT_LIMIT
    shots_used: int = 0
    logs: List[str] = Field(default_factory=list)
    # cached KPIs from the last non-dry run, if available
    last_kpis: Optional[KpiBundle] = None

    def add_log(self, message: str) -> None:
        now = datetime.utcnow().isoformat(timespec="seconds") + "Z"
        entry = f"[{now}] {message}"
        self.logs.append(entry)
        # avoid unbounded growth
        if len(self.logs) > 1000:
            # keep the most recent 1000 lines
            self.logs = self.logs[-1000:]


# -------------------------------------------------------------------------
# Simulation engine — SynQc-style, but compact
# -------------------------------------------------------------------------


@dataclass
class EngineConfig:
    """
    Parameters that govern the synthetic behavior.

    The goal is to emulate reasonable qualitative behavior for:
    - different hardware targets
    - different objectives
    - the trade-off between probe strength and back-action
    """

    base_latency_sim_local: float = 10.0
    base_latency_classical: float = 25.0
    base_latency_quantum: float = 80.0

    base_fidelity_sim_local: float = 0.99
    base_fidelity_classical: float = 0.985
    base_fidelity_quantum: float = 0.97

    shot_cost_baseline: int = 800
    shot_cost_per_ns: float = 0.3  # extra shots per ns of probe duration
    random_snr_db: float = 1.5  # jitter in effective SNR in dB units


class SynQcEngine:
    """
    Simple engine that maps (config, session state) → KPIs.

    Everything here is deterministic math + small noise, not full quantum
    simulation. It encodes our "research sense" of how these quantities move.
    """

    def __init__(self, cfg: Optional[EngineConfig] = None):
        self.cfg = cfg or EngineConfig()

    # Public API -------------------------------------------------------

    def run(self, session: SessionState, mode: RunMode) -> RunRecord:
        """
        Execute one run (or dry-run).

        For dry-run we still synthesize KPIs, but we do NOT charge shot
        budget.
        """
        run_id = self._new_run_id(session.session_id)
        created_at = datetime.utcnow()

        cfg = session.config

        kpis = self._simulate_kpis(cfg, session, count_shots=(mode == RunMode.RUN))
        events = self._explain_kpis(cfg, kpis, mode)

        # Update session state
        session.last_run_id = run_id
        session.last_updated_at = created_at
        session.last_kpis = kpis

        if mode == RunMode.RUN:
            session.shots_used = kpis.shots_used
            session.status = SessionStatus.IDLE
            session.status_text = "Idle · last run completed"
        else:
            session.status = SessionStatus.IDLE
            session.status_text = "Idle · last dry-run completed"

        # Add a top-level log line
        label = "SynQc run" if mode == RunMode.RUN else "SynQc dry-run"
        session.add_log(
            f"{label} finished – fidelity={kpis.fidelity:.3f}, "
            f"latency={kpis.latency_us:.1f}µs, back-action={kpis.backaction:.3f}, "
            f"shots_used={kpis.shots_used}/{kpis.shot_limit}"
        )

        return RunRecord(
            run_id=run_id,
            session_id=session.session_id,
            mode=mode,
            config_snapshot=cfg.copy(deep=True),
            created_at=created_at,
            kpis=kpis,
            events=events,
        )

    # Internals --------------------------------------------------------

    @staticmethod
    def _new_run_id(session_id: str) -> str:
        safe = session_id.replace(":", "_").replace("/", "_")
        stamp = datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
        return f"{safe}-{stamp}"

    def _simulate_kpis(
        self,
        cfg: RunConfiguration,
        session: SessionState,
        count_shots: bool,
    ) -> KpiBundle:
        # --- Baseline by hardware target --------------------------------
        ecfg = self.cfg

        if cfg.hardware_target == HardwareTarget.SIM_LOCAL:
            base_latency = ecfg.base_latency_sim_local
            base_fid = ecfg.base_fidelity_sim_local
        elif cfg.hardware_target == HardwareTarget.CLASSICAL_ONLY:
            base_latency = ecfg.base_latency_classical
            base_fid = ecfg.base_fidelity_classical
        else:
            base_latency = ecfg.base_latency_quantum
            base_fid = ecfg.base_fidelity_quantum

        # --- Adjustments by hardware preset -----------------------------
        if cfg.hardware_preset == HardwarePreset.TRANSMON_DEFAULT:
            base_fid += 0.0
            base_latency += 0.0
        elif cfg.hardware_preset == HardwarePreset.FLUXONIUM_PILOT:
            base_fid -= 0.005
            base_latency += 15.0
        elif cfg.hardware_preset == HardwarePreset.ION_CHAIN:
            base_fid += 0.005
            base_latency += 30.0
        elif cfg.hardware_preset == HardwarePreset.NEUTRAL_ATOM:
            base_fid -= 0.01
            base_latency += 45.0

        # --- Objective / adaptive rule tweaks ---------------------------
        latency = base_latency
        fid = base_fid

        if cfg.objective == Objective.MAXIMIZE_FIDELITY:
            fid += 0.005
            latency += 10.0
        elif cfg.objective == Objective.MINIMIZE_LATENCY:
            fid -= 0.007
            latency -= 12.0
        elif cfg.objective == Objective.INFO_VS_DAMAGE:
            # Balanced; small nudges
            fid += 0.002
            latency += 3.0
        elif cfg.objective == Objective.STABILITY_WINDOW:
            fid += 0.001
            latency += 5.0

        if cfg.adaptive_rule == AdaptiveRule.RL:
            # RL tends to be heavier compute; slightly slower loop
            latency += 8.0
        elif cfg.adaptive_rule == AdaptiveRule.KALMAN:
            # Filtered estimates help fidelity a bit
            fid += 0.003
        elif cfg.adaptive_rule == AdaptiveRule.BAYES:
            # More branching, slightly slower
            latency += 5.0

        # --- Probe strength & duration trade-offs -----------------------
        # There is an "optimal" probe_strength ~ 0.2; too low or too high hurts.
        eps = max(0.0, min(1.0, cfg.probe_strength))
        deviation = (eps - 0.2) / 0.2  # 0 at optimum

        # Quadratic penalty on fidelity
        fid -= 0.015 * deviation * deviation

        # Back-action grows with probe strength; mild penalty from long windows
        backaction = 0.08 + 0.4 * (eps ** 1.1) + 0.00005 * cfg.probe_duration_ns
        backaction = max(0.0, min(1.0, backaction))

        # Latency gets a small bump from probe window length
        latency += 0.01 * (cfg.probe_duration_ns / 10.0)

        # Envelope type influences timing slightly
        if cfg.drive_envelope == DriveEnvelope.GAUSSIAN:
            latency += 0.0
        elif cfg.drive_envelope == DriveEnvelope.SQUARE:
            latency -= 3.0
            fid -= 0.003
        elif cfg.drive_envelope == DriveEnvelope.DRAG:
            latency += 3.0
            fid += 0.004
        elif cfg.drive_envelope == DriveEnvelope.COSINE:
            latency += 1.0

        # --- Noise model via "effective SNR" ----------------------------
        # Treat SNR as an internal latent variable influencing both fidelity and
        # latency. We don't need to expose it directly; we only need consistent
        # jitter.
        rng = np.random.default_rng()
        snr_jitter_db = rng.normal(loc=0.0, scale=self.cfg.random_snr_db)
        snr_factor = math.exp(snr_jitter_db / 20.0)  # convert dB to multiplicative

        # Higher SNR → better fidelity, more stable latency
        fid *= min(1.02, max(0.95, snr_factor))
        latency /= min(1.05, max(0.95, snr_factor))

        # --- Shots used for this run ------------------------------------
        # Cost model: baseline + proportional to probe duration.
        base_shots = self.cfg.shot_cost_baseline
        extra = int(self.cfg.shot_cost_per_ns * cfg.probe_duration_ns)
        shots_this_run = max(100, base_shots + extra)

        # Dry-run doesn't consume shots
        prior_shots = session.shots_used
        if count_shots:
            total_shots = prior_shots + shots_this_run
        else:
            total_shots = prior_shots

        # Clip + sanitize
        fid = max(0.0, min(0.9999, fid))
        latency = max(1.0, float(latency))

        return KpiBundle.from_raw(
            fidelity=fid,
            latency_us=latency,
            backaction=backaction,
            shots_used=total_shots,
            shot_limit=session.shot_limit,
        )

    def _explain_kpis(
        self,
        cfg: RunConfiguration,
        kpis: KpiBundle,
        mode: RunMode,
    ) -> List[str]:
        """
        Generate human-readable events that describe the resulting KPIs.
        """

        events: List[str] = []
        label = "RUN" if mode == RunMode.RUN else "DRY-RUN"
        events.append(f"[{label}] Config objective={cfg.objective.value}, "
                      f"adaptive={cfg.adaptive_rule.value}, envelope={cfg.drive_envelope.value}")

        if kpis.fidelity >= 0.98:
            events.append(
                f"[KPIs] High fidelity regime (f={kpis.fidelity:.4f}); calibration stable."
            )
        elif kpis.fidelity >= 0.97:
            events.append(
                f"[KPIs] Good fidelity (f={kpis.fidelity:.4f}); small drifts acceptable."
            )
        else:
            events.append(
                f"[KPIs] Fidelity at {kpis.fidelity:.4f}; consider recalibrating or "
                f"reducing probe strength."
            )

        if kpis.latency_us <= 20.0:
            events.append(
                f"[KPIs] Low loop latency ({kpis.latency_us:.1f}µs); suitable for fast feedback."
            )
        elif kpis.latency_us <= 60.0:
            events.append(
                f"[KPIs] Moderate latency ({kpis.latency_us:.1f}µs); within nominal budget."
            )
        else:
            events.append(
                f"[KPIs] High latency ({kpis.latency_us:.1f}µs); bottleneck detected."
            )

        if kpis.backaction <= 0.15:
            events.append(
                f"[KPIs] Back-action low ({kpis.backaction:.3f}); probes are gentle."
            )
        elif kpis.backaction <= 0.3:
            events.append(
                f"[KPIs] Back-action moderate ({kpis.backaction:.3f}); acceptable trade-off."
            )
        else:
            events.append(
                f"[KPIs] Back-action elevated ({kpis.backaction:.3f}); consider weaker probes."
            )

        frac = kpis.shots_used_fraction
        used_pct = 100.0 * frac
        events.append(
            f"[BUDGET] Shot usage: {kpis.shots_used}/{kpis.shot_limit} "
            f"({used_pct:.1f}% of budget)."
        )

        if frac >= 0.95:
            events.append("[BUDGET] WARNING: Near shot budget exhaustion.")
        elif frac >= 0.75:
            events.append("[BUDGET] CAUTION: Shot usage high; plan refills.")

        return events


# -------------------------------------------------------------------------
# Persistent storage
# -------------------------------------------------------------------------


class StateStore:
    """
    File-backed store for sessions and runs.

    Layout under STATE_DIR:
    - sessions.json : list of SessionState objects (serialized)
    - runs/         : one JSON per RunRecord, named {run_id}.json
    """

    def __init__(self, root: Path):
        self.root = root
        self.root.mkdir(parents=True, exist_ok=True)
        (self.root / "runs").mkdir(parents=True, exist_ok=True)

        self.sessions: Dict[str, SessionState] = {}
        self._load_sessions()

    # --- session persistence -------------------------------------------

    def _sessions_path(self) -> Path:
        return self.root / "sessions.json"

    def _load_sessions(self) -> None:
        path = self._sessions_path()
        if not path.exists():
            self.sessions = {}
            return
        try:
            raw = json.loads(path.read_text(encoding="utf-8"))
            if not isinstance(raw, list):
                self.sessions = {}
                return
            loaded: Dict[str, SessionState] = {}
            for item in raw:
                try:
                    st = SessionState.model_validate(item)
                    loaded[st.session_id] = st
                except Exception:
                    continue
            self.sessions = loaded
        except Exception:
            self.sessions = {}

    def _save_sessions(self) -> None:
        data = [s.model_dump(mode="json") for s in self.sessions.values()]
        self._sessions_path().write_text(
            json.dumps(data, indent=2), encoding="utf-8"
        )

    # --- runs persistence ----------------------------------------------

    def _run_path(self, run_id: str) -> Path:
        return self.root / "runs" / f"{run_id}.json"

    def save_run(self, run: RunRecord) -> None:
        path = self._run_path(run.run_id)
        path.write_text(json.dumps(run.model_dump(mode="json"), indent=2), encoding="utf-8")

    def load_run(self, run_id: str) -> RunRecord:
        path = self._run_path(run_id)
        if not path.exists():
            raise FileNotFoundError(run_id)
        raw = json.loads(path.read_text(encoding="utf-8"))
        return RunRecord.model_validate(raw)

    # --- sessions API --------------------------------------------------

    def get_session(self, session_id: str) -> Optional[SessionState]:
        return self.sessions.get(session_id)

    def upsert_session(self, session: SessionState) -> SessionState:
        self.sessions[session.session_id] = session
        self._save_sessions()
        return session

    def all_sessions(self) -> List[SessionState]:
        return list(self.sessions.values())


# -------------------------------------------------------------------------
# FastAPI app
# -------------------------------------------------------------------------


app = FastAPI(
    title="SynQc Temporal Dynamics Series — Backend",
    description=(
        "Backend API that matches the SynQc Temporal Dynamics Series "
        "Control Panel v0.2 HTML controller. Provides session management, "
        "synthetic DPD KPIs, logging, and export."
    ),
    version="0.2.0",
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

store = StateStore(STATE_DIR)
engine = SynQcEngine()


# -------------------------------------------------------------------------
# API schemas (requests / responses)
# -------------------------------------------------------------------------


class SessionCreateRequest(BaseModel):
    session_id: Optional[str] = Field(
        None,
        description=(
            "Optional client-provided session ID. If omitted, the backend "
            "generates a new one of the form 'synqc-XXXXXX'."
        ),
    )
    config: RunConfiguration


class SessionSummary(BaseModel):
    session_id: str
    created_at: datetime
    last_updated_at: datetime
    status: SessionStatus
    status_text: str
    mode_label: str
    shot_limit: int
    shots_used: int
    shots_used_fraction: float
    last_run_id: Optional[str] = None
    last_kpis: Optional[KpiBundle] = None
    config: RunConfiguration

    @classmethod
    def from_state(cls, st: SessionState) -> "SessionSummary":
        frac = 0.0 if st.shot_limit <= 0 else min(1.0, st.shots_used / st.shot_limit)
        return cls(
            session_id=st.session_id,
            created_at=st.created_at,
            last_updated_at=st.last_updated_at,
            status=st.status,
            status_text=st.status_text,
            mode_label=st.mode_label,
            shot_limit=st.shot_limit,
            shots_used=st.shots_used,
            shots_used_fraction=frac,
            last_run_id=st.last_run_id,
            last_kpis=st.last_kpis,
            config=st.config,
        )


class RunRequest(BaseModel):
    mode: RunMode = RunMode.RUN


class RunResponse(BaseModel):
    run: RunRecord
    session: SessionSummary


class ExportFormat(str, Enum):
    JSON = "json"
    CSV = "csv"
    NOTEBOOK = "notebook"


# -------------------------------------------------------------------------
# Helper functions (session creation, mode label)
# -------------------------------------------------------------------------


def _derive_mode_label(target: HardwareTarget) -> str:
    if target == HardwareTarget.SIM_LOCAL:
        return "Local Simulation"
    if target == HardwareTarget.CLASSICAL_ONLY:
        return "Classical Hardware"
    return "Quantum Backend"


def _new_session_id() -> str:
    import secrets
    suffix = secrets.token_hex(3)
    return f"synqc-{suffix}"


# -------------------------------------------------------------------------
# Routes
# -------------------------------------------------------------------------


@app.get(f"{API_PREFIX}/health")
def health() -> Dict[str, Any]:
    """
    Lightweight health check plus basic configuration info.
    """
    return {
        "status": "ok",
        "version": app.version,
        "api_prefix": API_PREFIX,
        "state_dir": str(STATE_DIR),
        "allowed_origins": ALLOWED_ORIGINS,
    }


# --- Session CRUD -----------------------------------------------------


@app.get(f"{API_PREFIX}/sessions", response_model=List[SessionSummary])
def list_sessions() -> List[SessionSummary]:
    """
    List all known sessions. Useful for debugging and multi-session workflows.
    """
    return [SessionSummary.from_state(s) for s in store.all_sessions()]


@app.post(f"{API_PREFIX}/sessions", response_model=SessionSummary)
def create_or_update_session(req: SessionCreateRequest) -> SessionSummary:
    """
    Create a new session or update an existing one.

    The front-end should call this whenever the user changes a major
    configuration (hardware target/preset, envelopes, objectives, etc).
    """
    now = datetime.utcnow()

    if req.session_id:
        existing = store.get_session(req.session_id)
    else:
        existing = None

    if existing is None:
        session_id = req.session_id or _new_session_id()
        st = SessionState(
            session_id=session_id,
            created_at=now,
            last_updated_at=now,
            status=SessionStatus.IDLE,
            status_text="Idle · session created",
            mode_label=_derive_mode_label(req.config.hardware_target),
            config=req.config,
            shot_limit=DEFAULT_SHOT_LIMIT,
            shots_used=0,
        )
        st.add_log("Session created.")
    else:
        # Update configuration in-place
        st = existing
        st.config = req.config
        st.mode_label = _derive_mode_label(req.config.hardware_target)
        st.last_updated_at = now
        st.add_log("Configuration updated from front-end.")

    store.upsert_session(st)
    return SessionSummary.from_state(st)


@app.get(f"{API_PREFIX}/sessions/{{session_id}}", response_model=SessionSummary)
def get_session(session_id: str) -> SessionSummary:
    """
    Get full state for a session.
    """
    st = store.get_session(session_id)
    if st is None:
        raise HTTPException(status_code=404, detail=f"Session {session_id!r} not found.")
    return SessionSummary.from_state(st)


# --- Logs -------------------------------------------------------------


@app.get(f"{API_PREFIX}/sessions/{{session_id}}/logs")
def get_logs(
    session_id: str,
    limit: int = Query(200, ge=1, le=1000, description="Maximum lines to return."),
) -> Dict[str, Any]:
    """
    Return recent log lines for the session. This drives the 'Run Log & Events'
    panel in the HTML controller.
    """
    st = store.get_session(session_id)
    if st is None:
        raise HTTPException(status_code=404, detail=f"Session {session_id!r} not found.")
    logs = st.logs[-limit:]
    return {"session_id": session_id, "lines": logs}


@app.delete(f"{API_PREFIX}/sessions/{{session_id}}/logs")
def clear_logs(session_id: str) -> Dict[str, Any]:
    """
    Clear all logs for the session (used by 'Clear Log' button).
    """
    st = store.get_session(session_id)
    if st is None:
        raise HTTPException(status_code=404, detail=f"Session {session_id!r} not found.")
    st.logs = []
    st.last_updated_at = datetime.utcnow()
    st.add_log("Log cleared.")
    store.upsert_session(st)
    return {"status": "ok", "session_id": session_id}


# --- Run control ------------------------------------------------------


@app.post(f"{API_PREFIX}/sessions/{{session_id}}/run", response_model=RunResponse)
def launch_run(session_id: str, req: RunRequest) -> RunResponse:
    """
    Launch a SynQc run or dry-run for the given session.

    The HTML buttons map to:
    - Launch SynQc Run  → mode='run'
    - Dry-Run (no hardware) → mode='dryrun'
    """
    st = store.get_session(session_id)
    if st is None:
        raise HTTPException(status_code=404, detail=f"Session {session_id!r} not found.")

    if st.status == SessionStatus.RUNNING:
        raise HTTPException(status_code=409, detail="Session is already running.")

    st.status = SessionStatus.RUNNING
    st.status_text = "Running · SynQc DPD sequence in progress"
    st.last_updated_at = datetime.utcnow()
    st.add_log(f"Run requested with mode={req.mode.value}.")
    store.upsert_session(st)

    # For now, we execute synchronously. If later you want to offload to a
    # background worker, this is the hook.
    try:
        run = engine.run(st, mode=req.mode)
    except Exception as exc:  # pragma: no cover - defensive
        st.status = SessionStatus.ERROR
        st.status_text = f"Error during run: {exc}"
        st.add_log(f"Run failed with error: {exc}")
        store.upsert_session(st)
        raise

    # Persist results
    store.save_run(run)
    store.upsert_session(st)
    return RunResponse(run=run, session=SessionSummary.from_state(st))


@app.post(f"{API_PREFIX}/sessions/{{session_id}}/kill")
def kill_run(session_id: str) -> Dict[str, Any]:
    """
    Kill-switch endpoint. In this synchronous demo engine, this mainly
    records the user's intention and updates status/logs.
    """
    st = store.get_session(session_id)
    if st is None:
        raise HTTPException(status_code=404, detail=f"Session {session_id!r} not found.")

    if st.status != SessionStatus.RUNNING:
        st.add_log("Kill switch pressed with no active run.")
        store.upsert_session(st)
        return {
            "status": "no-active-run",
            "message": "Kill switch pressed with no active run.",
        }

    st.status = SessionStatus.TERMINATED
    st.status_text = "Idle · last run terminated via kill switch"
    st.last_updated_at = datetime.utcnow()
    st.add_log("Kill switch activated. Run terminated.")
    store.upsert_session(st)
    return {"status": "terminated", "session_id": session_id}


# --- Run retrieval ----------------------------------------------------


@app.get(f"{API_PREFIX}/runs/{{run_id}}", response_model=RunRecord)
def get_run(run_id: str) -> RunRecord:
    """
    Retrieve a stored RunRecord.
    """
    try:
        return store.load_run(run_id)
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail=f"Run {run_id!r} not found.")


# --- Export snapshot --------------------------------------------------


@app.get(f"{API_PREFIX}/sessions/{{session_id}}/export")
def export_snapshot(
    session_id: str,
    format: ExportFormat = Query(
        ExportFormat.JSON,
        description="Export format: json, csv, or notebook.",
    ),
):
    """
    Export a snapshot that mirrors the front-end's `buildExportPayload`:

    {
      "sessionId": ...,
      "mode": ...,
      "hardwareTarget": ...,
      "hardwarePreset": ...,
      "driveEnvelope": ...,
      "probeStrength": ...,
      "probeDurationNs": ...,
      "adaptiveRule": ...,
      "objective": ...,
      "kpis": { ... },
      "notes": ...,
      "exportedAt": ...
    }
    """
    st = store.get_session(session_id)
    if st is None:
        raise HTTPException(status_code=404, detail=f"Session {session_id!r} not found.")

    kpis = st.last_kpis or KpiBundle.from_raw(
        fidelity=0.0,
        latency_us=0.0,
        backaction=0.0,
        shots_used=st.shots_used,
        shot_limit=st.shot_limit,
    )

    data = {
        "sessionId": st.session_id,
        "mode": st.mode_label,
        "hardwareTarget": st.config.hardware_target.value,
        "hardwarePreset": st.config.hardware_preset.value,
        "driveEnvelope": st.config.drive_envelope.value,
        "probeStrength": st.config.probe_strength,
        "probeDurationNs": st.config.probe_duration_ns,
        "adaptiveRule": st.config.adaptive_rule.value,
        "objective": st.config.objective.value,
        "kpis": {
            "fidelity": kpis.fidelity,
            "latencyUs": kpis.latency_us,
            "backAction": kpis.backaction,
            "shotUsage": f"{kpis.shots_used} / {kpis.shot_limit}",
        },
        "notes": st.config.notes,
        "exportedAt": datetime.utcnow().isoformat(timespec="seconds") + "Z",
    }

    if format == ExportFormat.CSV:
        # Flatten the structure into a single CSV row
        flat = {
            "sessionId": data["sessionId"],
            "mode": data["mode"],
            "hardwareTarget": data["hardwareTarget"],
            "hardwarePreset": data["hardwarePreset"],
            "driveEnvelope": data["driveEnvelope"],
            "probeStrength": data["probeStrength"],
            "probeDurationNs": data["probeDurationNs"],
            "adaptiveRule": data["adaptiveRule"],
            "objective": data["objective"],
            "kpi_fidelity": data["kpis"]["fidelity"],
            "kpi_latencyUs": data["kpis"]["latencyUs"],
            "kpi_backAction": data["kpis"]["backAction"],
            "kpi_shotUsage": data["kpis"]["shotUsage"],
            "notes": data["notes"],
            "exportedAt": data["exportedAt"],
        }
        import io as _io
        buf = _io.StringIO()
        writer = csv_writer = None
        # Write header + row manually to avoid quoting headaches.
        header = list(flat.keys())
        writer = _io.StringIO()
        # Simple CSV construction: quote strings with commas or quotes
        def _csv_escape(value: Any) -> str:
            s = "" if value is None else str(value)
            if any(c in s for c in [",", "\"", "\n", "\r"]):
                s = '"' + s.replace('"', '""') + '"'
            return s

        header_line = ",".join(header)
        row_line = ",".join(_csv_escape(flat[k]) for k in header)
        csv_text = header_line + "\n" + row_line + "\n"
        return {
            "format": "csv",
            "payload": csv_text,
        }

    if format == ExportFormat.NOTEBOOK:
        # Provide a ready-to-paste Python cell
        cell = (
            "# SynQc TDS snapshot\n"
            "snapshot = "
            + json.dumps(data, indent=2)
            + "\n\n"
            "# Use `snapshot` inside your Jupyter pipeline.\n"
        )
        return {
            "format": "notebook",
            "payload": cell,
        }

    # Default JSON
    return {
        "format": "json",
        "payload": data,
    }


# -------------------------------------------------------------------------
# Main entry-point
# -------------------------------------------------------------------------


if __name__ == "__main__":
    import uvicorn

    host = _env("SYNQC_HOST", "0.0.0.0")
    try:
        port = int(_env("SYNQC_PORT", "8000"))
    except ValueError:
        port = 8000

    uvicorn.run("synqc_tds_super_backend:app", host=host, port=port, reload=True)
