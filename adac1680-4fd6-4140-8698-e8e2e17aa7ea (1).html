
     <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SynQc TDS — Interstellar Control Console</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg-main: #020318;
      --bg-panel: #090b1c;
      --bg-panel-alt: #0f1224;
      --accent: #53a8ff;
      --accent-soft: rgba(83, 168, 255, 0.16);
      --accent-strong: #ffdd6e;
      --danger: #ff5468;
      --border-subtle: #262a3f;
      --text-main: #f7f8ff;
      --text-muted: #a4a7c7;
      --text-soft: #7a7da0;
      --radius-lg: 16px;
      --radius-md: 11px;
      --radius-pill: 999px;
      --shadow-soft: 0 22px 60px rgba(0, 0, 0, 0.7);
      --shadow-subtle: 0 0 0 1px rgba(255, 255, 255, 0.03);
    }
    /* Qubit visualizer styles */
    .qubit-visualizer {
      margin-top: 0.6rem;
      padding-top: 0.5rem;
      border-top: 1px dashed rgba(255,255,255,0.03);
    }

    .qubit-grid {
      display: flex;
      gap: 0.6rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .qubit-sphere {
      width: 72px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.45rem;
      font-size: 0.75rem;
      color: var(--text-soft);
    }

    .qubit-sphere-inner {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid rgba(255,255,255,0.04);
      box-shadow: 0 6px 18px rgba(0,0,0,0.6);
      transition: transform 0.18s ease, box-shadow 0.18s ease;
    }

    .qubit-value {
      font-weight: 700;
      color: var(--text-main);
      font-size: 1.0rem;
    }

    .qubit-meta {
      text-align: center;
      color: var(--text-soft);
      font-size: 0.68rem;
      line-height: 1.05;
    }

    .qubit-sphere[data-state="zero"] .qubit-sphere-inner {
      background: linear-gradient(180deg, rgba(100,170,255,0.18), rgba(70,140,220,0.12));
      box-shadow: 0 8px 22px rgba(83,168,255,0.12);
      transform: translateY(-3px);
    }

    .qubit-sphere[data-state="one"] .qubit-sphere-inner {
      background: linear-gradient(180deg, rgba(255,180,120,0.14), rgba(255,140,60,0.08));
      box-shadow: 0 8px 22px rgba(255,140,60,0.12);
      transform: translateY(-3px);
    }

    .qubit-sphere[data-state="superposition"] .qubit-sphere-inner {
      background: radial-gradient(circle at 30% 30%, rgba(155,92,255,0.18), rgba(83,168,255,0.12));
      box-shadow: 0 8px 28px rgba(155,92,255,0.10);
      transform: translateY(-2px) rotate(6deg);
    }

    .qubit-sphere[data-state="idle"] .qubit-sphere-inner {
      opacity: 0.9;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at 20% -10%, #2e3c7f 0, transparent 55%),
        radial-gradient(circle at 80% 10%, #5a2f7e 0, transparent 55%),
        radial-gradient(circle at 10% 90%, #224c6f 0, transparent 55%),
        radial-gradient(circle at 90% 80%, #5f2f5f 0, transparent 55%),
        #020318;
      color: var(--text-main);
      -webkit-font-smoothing: antialiased;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }

    /* starfield overlay */
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background-image:
        radial-gradient(1px 1px at 10% 20%, rgba(255,255,255,0.65), transparent),
        radial-gradient(1px 1px at 30% 80%, rgba(255,255,255,0.7), transparent),
        radial-gradient(1px 1px at 70% 10%, rgba(255,255,255,0.7), transparent),
        radial-gradient(1px 1px at 90% 70%, rgba(255,255,255,0.6), transparent),
        radial-gradient(circle at 20% 30%, rgba(111, 179, 255, 0.25), transparent 55%),
        radial-gradient(circle at 80% 70%, rgba(255, 182, 132, 0.25), transparent 55%);
      opacity: 0.42;
      mix-blend-mode: screen;
      z-index: -1;
    }

    h1,
    h2,
    h3 {
      margin: 0;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    p {
      margin: 0;
    }

    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.75rem;
    }

    canvas.bg-scene {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
      opacity: 0.95;
    }

    header.app-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.25rem 1.75rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(16px);
      background:
        radial-gradient(circle at 0% 0%, rgba(103, 154, 255, 0.22), transparent 60%),
        radial-gradient(circle at 100% 0%, rgba(227, 139, 255, 0.22), transparent 55%),
        linear-gradient(to right, rgba(5, 7, 20, 0.96), rgba(8, 11, 32, 0.96));
      position: sticky;
      top: 0;
      z-index: 20;
      position: relative;
    }

    .attribution {
      position: absolute;
      top: 0.75rem;
      right: 1.75rem;
      font-size: 0.625rem;
      font-weight: 700;
      letter-spacing: 0.05em;
      color: var(--accent-strong);
      text-transform: uppercase;
      font-style: italic;
      text-shadow: 0 0 12px rgba(255, 221, 110, 0.3);
      font-family: Georgia, serif;
      text-decoration: underline dashed var(--accent-strong);
      text-decoration-skip-ink: auto;
    }

    .logo-block {
      display: flex;
      align-items: center;
      gap: 0.9rem;
    }

    .logo-dot {
      width: 38px;
      height: 38px;
      border-radius: 50%;
      background:
        radial-gradient(circle at 35% 30%, #ffffff 0, #d2e8ff 12%, transparent 55%),
        conic-gradient(from 210deg, #53a8ff, #9b5cff, #ffdd6e, #53a8ff);
      box-shadow:
        0 0 40px rgba(83, 168, 255, 0.9),
        0 0 0 1px rgba(255, 255, 255, 0.18);
      position: relative;
      overflow: hidden;
    }

    .logo-dot::after {
      content: "";
      position: absolute;
      inset: 35%;
      border-radius: inherit;
      border: 1px solid rgba(255, 255, 255, 0.35);
      opacity: 0.7;
    }

    .logo-block h1 {
      font-size: 1.15rem;
    }

    .logo-block p {
      font-size: 0.78rem;
      color: var(--text-soft);
      margin-top: 0.1rem;
    }

    .session-info {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.1rem;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .session-info span {
      color: var(--text-main);
      font-weight: 500;
    }

    .status-pill {
      padding: 0.2rem 0.7rem;
      border-radius: var(--radius-pill);
      background: var(--accent-soft);
      color: var(--accent);
      font-size: 0.72rem;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
    }

    .status-dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 8px rgba(83, 168, 255, 0.9);
    }

    #globalStatus {
      position: fixed;
      left: 50%;
      transform: translateX(-50%) translateY(10px);
      bottom: 1.25rem;
      padding: 0.42rem 1rem;
      border-radius: var(--radius-pill);
      background: rgba(7, 9, 26, 0.96);
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: var(--text-muted);
      font-size: 0.78rem;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.18s ease, transform 0.18s ease;
      max-width: 90vw;
      z-index: 40;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #globalStatus.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
      pointer-events: auto;
    }

    #globalStatus[data-level="ok"] {
      border-color: rgba(83, 168, 255, 0.7);
      color: #c0dcff;
    }

    #globalStatus[data-level="error"] {
      border-color: rgba(255, 84, 104, 0.8);
      color: #ffd4dc;
    }

    #globalStatus[data-level="warn"] {
      border-color: rgba(255, 221, 110, 0.8);
      color: #fff1c5;
    }

    main.app-grid {
      display: grid;
      grid-template-columns: minmax(260px, 280px) minmax(320px, 3fr) minmax(260px, 320px);
      grid-auto-rows: minmax(160px, auto);
      gap: 1rem;
      padding: 1rem 1.5rem 2.5rem;
      position: relative;
      z-index: 1;
    }

    .panel {
      background:
        radial-gradient(circle at 0% 0%, rgba(117, 153, 255, 0.14), transparent 55%),
        radial-gradient(circle at 100% 100%, rgba(255, 176, 117, 0.12), transparent 55%),
        linear-gradient(to bottom right, rgba(9, 11, 31, 0.98), rgba(6, 7, 24, 0.98));
      border-radius: var(--radius-lg);
      padding: 0.9rem 1rem 1.1rem;
      box-shadow: var(--shadow-soft), var(--shadow-subtle);
      border: 1px solid rgba(255, 255, 255, 0.05);
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
      position: relative;
      overflow: hidden;
    }

    .panel::before {
      content: "";
      position: absolute;
      inset: -40%;
      background:
        radial-gradient(circle at 10% 10%, rgba(255,255,255,0.04), transparent 55%),
        radial-gradient(circle at 80% 0%, rgba(121, 159, 255, 0.07), transparent 55%);
      opacity: 0.6;
      pointer-events: none;
      mix-blend-mode: soft-light;
    }

    .panel > * {
      position: relative;
      z-index: 1;
    }

    .panel h2 {
      font-size: 0.95rem;
      margin-bottom: 0.15rem;
    }

    .panel h3 {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-top: 0.4rem;
    }

    .panel--backend {
      grid-column: 1 / 2;
      grid-row: 1 / 3;
    }

    .panel--config {
      grid-column: 2 / 3;
      grid-row: 1 / 2;
    }

    .panel--kpi {
      grid-column: 3 / 4;
      grid-row: 1 / 2;
    }

    .panel--telemetry {
      grid-column: 2 / 4;
      grid-row: 2 / 3;
    }

    .panel--log {
      grid-column: 1 / 3;
      grid-row: 3 / 4;
    }

    .panel--export {
      grid-column: 3 / 4;
      grid-row: 3 / 4;
    }

    label {
      font-size: 0.78rem;
      color: var(--text-muted);
      display: flex;
      flex-direction: column;
      gap: 0.22rem;
      margin-bottom: 0.3rem;
    }

    input[type="text"],
    input[type="number"],
    select,
    textarea {
      background: rgba(4, 6, 20, 0.96);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.07);
      padding: 0.45rem 0.55rem;
      color: var(--text-main);
      font-size: 0.8rem;
      outline: none;
      transition:
        border 0.15s ease,
        background 0.15s ease,
        box-shadow 0.15s ease,
        transform 0.05s ease;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    select:focus,
    textarea:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(83, 168, 255, 0.4);
      background: rgba(4, 7, 24, 1);
      transform: translateY(-0.5px);
    }

    textarea {
      resize: vertical;
      min-height: 70px;
      max-height: 260px;
      line-height: 1.3;
    }

    input[type="range"] {
      width: 100%;
      -webkit-appearance: none;
      appearance: none;
      height: 4px;
      border-radius: 999px;
      background: linear-gradient(90deg, #53a8ff 0%, #4ee1a8 55%, #ffdd6e 100%);
      outline: none;
      margin: 0.4rem 0;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #ffffff;
      border: 2px solid #53a8ff;
      box-shadow: 0 0 12px rgba(83, 168, 255, 0.7);
      cursor: pointer;
    }

    input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #ffffff;
      border: 2px solid #53a8ff;
      box-shadow: 0 0 12px rgba(83, 168, 255, 0.7);
      cursor: pointer;
    }

    .range-row {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .range-value {
      font-size: 0.78rem;
      color: var(--text-muted);
      min-width: 3.2rem;
      text-align: right;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-top: 0.15rem;
    }

    button {
      border-radius: var(--radius-pill);
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(14, 18, 42, 0.9);
      color: var(--text-main);
      font-size: 0.78rem;
      padding: 0.38rem 0.8rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
      transition:
        background 0.15s ease,
        border 0.15s ease,
        transform 0.06s ease,
        box-shadow 0.2s ease;
      white-space: nowrap;
    }

    button.primary {
      background: linear-gradient(135deg, #53a8ff, #4ee1a8);
      border-color: rgba(255, 255, 255, 0.18);
      color: #020318;
      font-weight: 600;
      box-shadow: 0 12px 26px rgba(83, 168, 255, 0.55);
    }

    button.danger {
      background: rgba(255, 84, 104, 0.1);
      border-color: rgba(255, 84, 104, 0.7);
      color: #ff9cab;
    }

    button.small {
      font-size: 0.72rem;
      padding: 0.25rem 0.6rem;
    }

    button:disabled {
      opacity: 0.45;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    button:not(:disabled):hover {
      background: rgba(22, 28, 64, 0.98);
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.65);
    }

    button.primary:not(:disabled):hover {
      background: linear-gradient(135deg, #66b2ff, #5befb2);
      box-shadow: 0 16px 32px rgba(83, 168, 255, 0.65);
    }

    button.danger:not(:disabled):hover {
      background: rgba(255, 84, 104, 0.17);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: none;
    }

    .help-text {
      font-size: 0.72rem;
      color: var(--text-soft);
    }

    .session-list {
      margin-top: 0.3rem;
      border-radius: var(--radius-md);
      background: rgba(5, 7, 20, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.04);
      max-height: 190px;
      overflow: hidden auto;
      padding: 0.15rem;
    }

    .session-row {
      width: 100%;
      justify-content: space-between;
      background: transparent;
      border-radius: var(--radius-md);
      padding: 0.3rem 0.4rem;
      border: none;
      border-bottom: 1px solid rgba(255, 255, 255, 0.03);
      font-size: 0.75rem;
      color: var(--text-soft);
    }

    .session-row strong {
      color: var(--text-main);
      font-weight: 500;
    }

    .session-row:last-child {
      border-bottom: none;
    }

    .session-row.active {
      background: rgba(83, 168, 255, 0.16);
      color: var(--text-main);
    }

    .session-row:hover:not(.active) {
      background: rgba(255, 255, 255, 0.02);
    }

    .session-row-id {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.7rem;
    }

    .session-row-status {
      font-size: 0.7rem;
      color: var(--text-soft);
      margin-left: 0.3rem;
    }

    .grid-two {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.5rem;
    }

    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(140px, 1fr));
      gap: 0.6rem;
      margin-top: 0.35rem;
    }

    .kpi-card {
      background:
        radial-gradient(circle at 0% 0%, rgba(120, 167, 255, 0.18), transparent 65%),
        radial-gradient(circle at 100% 100%, rgba(255, 198, 135, 0.16), transparent 65%),
        linear-gradient(to bottom right, #0a0d26, #060819);
      border-radius: 12px;
      padding: 0.55rem 0.7rem;
      border: 1px solid rgba(255, 255, 255, 0.06);
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
      min-height: 78px;
    }

    .kpi-title {
      font-size: 0.76rem;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.4rem;
    }

    .badge {
      padding: 0.08rem 0.45rem;
      border-radius: 999px;
      background: rgba(28, 34, 64, 0.9);
      color: var(--accent-strong);
      font-size: 0.65rem;
      white-space: nowrap;
    }

    .kpi-value {
      font-size: 1.1rem;
      font-weight: 600;
      margin-top: 0.12rem;
    }

    .kpi-sub {
      font-size: 0.72rem;
      color: var(--text-soft);
    }

    .kpi-sub.positive {
      color: #5befb2;
    }

    .kpi-sub.negative {
      color: #ff9cab;
    }

    .log-output {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: rgba(4, 6, 20, 0.98);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.06);
      padding: 0.5rem 0.55rem;
      font-size: 0.72rem;
      color: #d0d3ea;
      max-height: 260px;
      overflow-y: auto;
      margin-top: 0.25rem;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .inline {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    .inline input[type="checkbox"] {
      margin: 0;
    }

    .export-output {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.72rem;
      background: rgba(4, 6, 20, 0.98);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.06);
      margin-top: 0.35rem;
      padding: 0.45rem 0.55rem;
      min-height: 120px;
      max-height: 260px;
    }

    .run-info {
      font-size: 0.74rem;
      color: var(--text-soft);
      margin-top: 0.2rem;
    }

    .run-info code {
      background: rgba(255, 255, 255, 0.05);
      padding: 0.1rem 0.35rem;
      border-radius: 999px;
    }

    .telemetry-table-wrapper {
      margin-top: 0.4rem;
      border-radius: var(--radius-md);
      background: rgba(4, 6, 20, 0.96);
      border: 1px solid rgba(255, 255, 255, 0.06);
      max-height: 260px;
      overflow: hidden auto;
    }

    .telemetry-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.75rem;
    }

    .telemetry-table th,
    .telemetry-table td {
      padding: 0.28rem 0.45rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.04);
      text-align: left;
    }

    .telemetry-table th {
      color: var(--text-muted);
      font-weight: 500;
      background: rgba(10, 13, 31, 0.95);
      position: sticky;
      top: 0;
      z-index: 1;
    }

    .telemetry-table tbody tr:nth-child(even) {
      background: rgba(255, 255, 255, 0.01);
    }

    .telemetry-empty {
      text-align: center;
      color: var(--text-soft);
      padding: 0.5rem 0;
    }

    #clampWarningBanner {
      display: none;
      position: fixed;
      top: 4.5rem;
      left: 0;
      right: 0;
      background: linear-gradient(90deg, rgba(255, 221, 110, 0.15), rgba(255, 176, 117, 0.12));
      border-bottom: 1px solid rgba(255, 221, 110, 0.6);
      padding: 0.6rem 1.5rem;
      font-size: 0.8rem;
      color: #fff1c5;
      z-index: 35;
      box-shadow: 0 4px 12px rgba(255, 221, 110, 0.2);
    }

    #clampWarningBanner.visible {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    #clampWarningBanner .clamp-message {
      flex: 1;
    }

    #clampWarningBanner .clamp-close {
      cursor: pointer;
      font-size: 1.2rem;
      opacity: 0.7;
      transition: opacity 0.2s ease;
    }

    #clampWarningBanner .clamp-close:hover {
      opacity: 1;
    }

    /* --- Agent Chatbot Section --- */
    .agent-chat-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 380px;
      height: 520px;
      background:
        radial-gradient(circle at 0% 0%, rgba(117, 153, 255, 0.14), transparent 55%),
        radial-gradient(circle at 100% 100%, rgba(255, 176, 117, 0.12), transparent 55%),
        linear-gradient(to bottom right, rgba(9, 11, 31, 0.98), rgba(6, 7, 24, 0.98));
      border-radius: var(--radius-lg);
      border: 1px solid rgba(255, 255, 255, 0.05);
      box-shadow: var(--shadow-soft), var(--shadow-subtle);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      z-index: 30;
      transition: all 0.3s ease;
    }

    .agent-chat-container.minimized {
      height: 56px;
      width: 200px;
    }

    .agent-chat-header {
      background: linear-gradient(90deg, rgba(83, 168, 255, 0.15), rgba(78, 225, 168, 0.1));
      padding: 12px 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }

    .agent-chat-header h3 {
      margin: 0;
      font-size: 0.9rem;
      color: var(--accent);
      font-weight: 600;
    }

    .agent-chat-header .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 8px rgba(83, 168, 255, 0.7);
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      
      function initChatAgent() {
        const input = document.getElementById("chatInput");
        const sendBtn = document.getElementById("btnChatSend");
        const clearBtn = document.getElementById("btnChatClear");
        const logEl = document.getElementById("chatLog");

        if (!input || !sendBtn || !logEl) return;

        function renderChatLog() {
          logEl.innerHTML = "";
          if (!state.chatHistory || !state.chatHistory.length) {
            const empty = document.createElement("div");
            empty.className = "chat-msg chat-msg--assistant";
            empty.innerHTML =
              '<div class="chat-msg-meta">Agent</div>' +
              '<div class="chat-msg-body">No messages yet. Ask something about this session.</div>';
            logEl.appendChild(empty);
            return;
          }

          state.chatHistory.forEach((m) => {
            const item = document.createElement("div");
            item.className =
              "chat-msg " +
              (m.role === "user" ? "chat-msg--user" : "chat-msg--assistant");
            const meta = document.createElement("div");
            meta.className = "chat-msg-meta";
            meta.textContent = m.role === "user" ? "You" : "Agent";
            const body = document.createElement("div");
            body.className = "chat-msg-body";
            body.textContent = m.content;
            item.appendChild(meta);
            item.appendChild(body);
            logEl.appendChild(item);
          });

          logEl.scrollTop = logEl.scrollHeight;
        }

        function pushMessage(role, content) {
          if (!state.chatHistory) state.chatHistory = [];
          state.chatHistory.push({ role, content });
          renderChatLog();
        }

        function sendCurrentMessage() {
          const raw = input.value.trim();
          if (!raw) return;

          const sessionId =
            state.session && state.session.session_id
              ? state.session.session_id
              : null;

          pushMessage("user", raw);
          input.value = "";
          sendBtn.disabled = true;

          const payload = {
            session_id: sessionId,
            message: raw,
            history: (state.chatHistory || []).slice(-10),
          };

          apiFetch("/chat", {
            method: "POST",
            body: JSON.stringify(payload),
          })
            .then((resp) => {
              const reply =
                resp && typeof resp.reply === "string"
                  ? resp.reply
                  : "[no reply from backend]";
              pushMessage("assistant", reply);
              showStatus(
                "Agent replied" + (sessionId ? " for " + sessionId : ""),
                "ok"
              );
            })
            .catch((err) => {
              pushMessage(
                "assistant",
                "Chat backend error: " + err.message
              );
              showStatus("Chat request failed: " + err.message, "error");
            })
            .finally(() => {
              sendBtn.disabled = false;
            });
        }

        sendBtn.addEventListener("click", sendCurrentMessage);

        input.addEventListener("keydown", (evt) => {
          if (evt.key === "Enter" && !evt.shiftKey) {
            evt.preventDefault();
            sendCurrentMessage();
          }
        });

        if (clearBtn) {
          clearBtn.addEventListener("click", () => {
            state.chatHistory = [];
            renderChatLog();
          });
        }

        renderChatLog();
      }
      50% {
        opacity: 0.5;
      }
    }

    .agent-chat-minimize-btn {
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 0.8rem;
      cursor: pointer;
      padding: 0;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color 0.2s ease;
    }

    .agent-chat-minimize-btn:hover {
      color: var(--text-main);
    }

    .agent-chat-body {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .agent-chat-body::-webkit-scrollbar {
      width: 6px;
    }

    .agent-chat-body::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.02);
    }

    .agent-chat-body::-webkit-scrollbar-thumb {
      background: rgba(83, 168, 255, 0.3);
      border-radius: 3px;
    }

    .agent-chat-body::-webkit-scrollbar-thumb:hover {
      background: rgba(83, 168, 255, 0.5);
    }

    .agent-message {
      display: flex;
      gap: 8px;
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(8px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .agent-message.user {
      justify-content: flex-end;
    }

    .agent-message.system {
      justify-content: center;
    }

    .agent-message-bubble {
      max-width: 85%;
      padding: 8px 12px;
      border-radius: var(--radius-md);
      font-size: 0.8rem;
      line-height: 1.4;
      word-wrap: break-word;
      white-space: pre-wrap;
    }

    .agent-message.agent .agent-message-bubble {
      background: rgba(83, 168, 255, 0.12);
      color: var(--text-main);
      border: 1px solid rgba(83, 168, 255, 0.2);
    }

    .agent-message.user .agent-message-bubble {
      background: linear-gradient(135deg, rgba(83, 168, 255, 0.3), rgba(78, 225, 168, 0.2));
      color: var(--text-main);
      border: 1px solid rgba(83, 168, 255, 0.4);
    }

    .agent-message.system .agent-message-bubble {
      background: rgba(255, 221, 110, 0.08);
      color: var(--text-muted);
      border: 1px solid rgba(255, 221, 110, 0.2);
      font-size: 0.72rem;
      font-style: italic;
    }

    .agent-message-loading {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .agent-message-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent);
      opacity: 0.6;
      animation: bounce 1.2s ease-in-out infinite;
    }

    .agent-message-dot:nth-child(2) {
      animation-delay: 0.2s;
    }

    .agent-message-dot:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes bounce {
      0%, 80%, 100% {
        opacity: 0.4;
        transform: translateY(0);
      }
      40% {
        opacity: 1;
        transform: translateY(-6px);
      }
    }

    .agent-chat-footer {
      padding: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      display: flex;
      gap: 8px;
    }

    .agent-chat-footer input {
      flex: 1;
      background: rgba(4, 6, 20, 0.96);
      border-radius: var(--radius-pill);
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 8px 12px;
      color: var(--text-main);
      font-size: 0.78rem;
      outline: none;
      transition: border 0.15s ease, box-shadow 0.15s ease;
    }

    .agent-chat-footer input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(83, 168, 255, 0.4);
    }

    .agent-chat-footer input::placeholder {
      color: var(--text-soft);
    }

    .agent-chat-footer button {
      padding: 8px 12px;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(83, 168, 255, 0.5);
      background: linear-gradient(135deg, rgba(83, 168, 255, 0.15), rgba(78, 225, 168, 0.1));
      color: var(--accent);
      font-size: 0.75rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .agent-chat-footer button:hover:not(:disabled) {
      background: linear-gradient(135deg, rgba(83, 168, 255, 0.25), rgba(78, 225, 168, 0.2));
      box-shadow: 0 0 12px rgba(83, 168, 255, 0.3);
    }

    .agent-chat-footer button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .agent-chat-container.minimized .agent-chat-body,
    .agent-chat-container.minimized .agent-chat-footer {
      display: none;
    }

    @media (max-width: 1024px) {
      .agent-chat-container {
        width: 320px;
        height: 480px;
      }
    }

    @media (max-width: 640px) {
      .agent-chat-container {
        width: 280px;
        height: 420px;
      }

      .agent-chat-container.minimized {
        width: 160px;
      }
    }

    @media (max-width: 480px) {
      .agent-chat-container {
        width: calc(100vw - 10px);
        height: 380px;
      }
    }

    @media (max-width: 1024px) {
      main.app-grid {
        grid-template-columns: 1fr;
      }

      .panel {
        grid-column: auto;
        grid-row: auto;
      }

      .kpi-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 640px) {
      header.app-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.7rem;
      }

      .session-info {
        align-items: flex-start;
      }

      .kpi-grid {
        grid-template-columns: 1fr;
      }

      .session-list {
        max-height: 160px;
      }
    }

    /* --- Agent panel (in-grid) --- */
    .panel--agent {
      grid-column: 1 / 4;
      grid-row: 4 / 5;
    }

    .chat-container {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      height: 100%;
      min-height: 220px;
    }

    .chat-log {
      flex: 1;
      min-height: 150px;
      max-height: 260px;
      overflow-y: auto;
      padding: 0.45rem 0.55rem;
      border-radius: var(--radius-md);
      background: rgba(4, 6, 20, 0.98);
      border: 1px solid rgba(255, 255, 255, 0.06);
      font-size: 0.78rem;
    }

    .chat-msg {
      margin-bottom: 0.45rem;
      display: flex;
      flex-direction: column;
      gap: 0.15rem;
    }

    .chat-msg:last-child {
      margin-bottom: 0;
    }

    .chat-msg-meta {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-soft);
    }

    .chat-msg-body {
      padding: 0.4rem 0.5rem;
      border-radius: 10px;
      line-height: 1.35;
      background: rgba(14, 18, 42, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.04);
      white-space: pre-wrap;
      word-break: break-word;
    }

    .chat-msg--user .chat-msg-body {
      align-self: flex-end;
      background: rgba(83, 168, 255, 0.18);
      border-color: rgba(83, 168, 255, 0.6);
    }

    .chat-msg--assistant .chat-msg-body {
      align-self: flex-start;
      background: rgba(23, 27, 58, 0.98);
    }

    .chat-input-row {
      display: flex;
      gap: 0.45rem;
      align-items: flex-end;
    }

    .chat-input {
      flex: 1;
      background: rgba(4, 6, 20, 0.96);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.07);
      padding: 0.4rem 0.5rem;
      color: var(--text-main);
      font-size: 0.8rem;
      resize: vertical;
      min-height: 44px;
      max-height: 120px;
      outline: none;
    }

    .chat-input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(83, 168, 255, 0.4);
      background: rgba(4, 7, 24, 1);
    }

    .chat-button-column {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
    }

    @media (max-width: 640px) {
      .panel--agent {
        grid-column: auto;
        grid-row: auto;
      }

      .chat-input-row {
        flex-direction: column;
        align-items: stretch;
      }

      .chat-button-column {
        flex-direction: row;
        justify-content: flex-end;
      }
    }
  </style>
</head>
<body>
  <header class="app-header">
    <div class="attribution">Developed by <strong>eVision Enterprises</strong></div>
    <div class="logo-block">
      <div class="logo-dot"></div>
      <div>
        <h1>SynQc Temporal Dynamics Series</h1>
        <p>Interstellar Drive–Probe–Drive Control Console</p>
      </div>
    </div>
    <div class="session-info">
      <div>Mode: <span id="sessionModeLabel">Local Simulation</span></div>
      <div>Session: <span id="sessionId">—</span></div>
      <div>Shots (this session): <span id="shotsCounter">0</span></div>
      <div>
        <span class="status-pill">
          <span class="status-dot"></span>
          <span id="sessionStatus">No session yet</span>
        </span>
      </div>
    </div>
  </header>

  <div id="globalStatus" data-level="ok">Ready.</div>

  <div id="clampWarningBanner">
    <div class="clamp-message" id="clampMessage">Server applied parameter clamps to ensure safety.</div>
    <span class="clamp-close" id="clampClose">✕</span>
  </div>

  <main class="app-grid">
    <!-- Backend & Session -->
    <section class="panel panel--backend">
      <h2>Backend & Session</h2>
      <label for="apiBase">
        API base URL
        <input
          id="apiBase"
          type="text"
          spellcheck="false"
          autocomplete="off"
          placeholder="http://localhost:8000/api/v1/synqc"
        />
      </label>
      <label for="apiKey">
        API key (optional)
        <input
          id="apiKey"
          type="text"
          spellcheck="false"
          autocomplete="off"
          placeholder="X-API-Key value"
        />
      </label>
      <p class="help-text">
        Backend can enforce <code>X-API-Key</code> for multi-user labs or cloud gateways.
      </p>
      <div class="button-row">
        <button id="btnHealth" class="small">Ping backend</button>
        <button id="btnRefreshSessions" class="small">Refresh sessions</button>
      </div>

      <h3>Session lifecycle</h3>
      <div class="button-row">
        <button id="btnNewSession" class="primary small">New session</button>
        <button id="btnSaveSession" class="small">Save session</button>
      </div>
      <p class="help-text">
        New session creates a fresh ID. Save updates the active session’s configuration on the backend.
      </p>

      <h3>Sessions on disk</h3>
      <div id="sessionList" class="session-list">
        <p class="help-text" style="padding:0.3rem 0.4rem;">
          No sessions yet. Press “New session”.
        </p>
      </div>

      <h2>Hardware stack</h2>
      <label for="hardwareTarget">
        Provider
        <select id="hardwareTarget">
          <option value="sim-local">Local simulator (CPU)</option>
          <option value="ibm-qpu">IBM Quantum QPU</option>
          <option value="aws-bracket">AWS Bracket</option>
          <option value="ionq">IonQ</option>
          <option value="classical-only">Classical lab hardware only</option>
        </select>
      </label>
      <label for="hardwarePreset">
        Hardware preset
        <select id="hardwarePreset">
          <option value="transmon-default">Transmon default · 5–27q</option>
          <option value="fluxonium-pilot">Fluxonium pilot · 2–5q</option>
          <option value="ion-chain">Trapped-ion chain · 11–32q</option>
          <option value="neutral-atom">Neutral atom array · 100+ sites</option>
        </select>
      </label>

      <h2>Notes</h2>
      <label for="notes">
        Session / run annotation
        <textarea
          id="notes"
          placeholder="e.g. Transmon, 5q, sweet spot search, 4K, SynQc TDS v0.3 test."
        ></textarea>
      </label>
    </section>

    <!-- Config -->
    <section class="panel panel--config">
      <h2>Drive–Probe–Drive configuration</h2>
      <div class="grid-two">
        <label for="driveEnvelope">
          Drive envelope
          <select id="driveEnvelope">
            <option value="gaussian">Gaussian</option>
            <option value="square">Square</option>
            <option value="drag">DRAG</option>
            <option value="cosine">Cosine flat-top</option>
          </select>
        </label>
        <label for="adaptiveRule">
          Adaptive rule
          <select id="adaptiveRule">
            <option value="none">None (fixed)</option>
            <option value="kalman">Kalman update</option>
            <option value="bayes">Bayesian branching</option>
            <option value="rl">RL controller</option>
          </select>
        </label>
      </div>

      <label>
        Probe strength (ε)
        <div class="range-row">
          <input id="probeStrength" type="range" min="0" max="1" step="0.01" value="0.2" />
          <div class="range-value">
            <span id="probeStrengthValue">0.200</span>
          </div>
        </div>
      </label>

      <label>
        Probe duration (τₚ, ns)
        <div class="range-row">
          <input id="probeDuration" type="range" min="5" max="5000" step="5" value="120" />
          <div class="range-value">
            <span id="probeDurationValue">120</span> ns
          </div>
        </div>
      </label>

      <div class="grid-two">
        <label for="numIterations">
          Iterations per run
          <input
            id="numIterations"
            type="number"
            min="1"
            max="10000"
            step="1"
            value="5"
          />
        </label>
        <label for="shotLimit">
          Shot limit per run
          <input
            id="shotLimit"
            type="number"
            min="128"
            max="1000000"
            step="128"
            value="4096"
          />
        </label>
      </div>

      <label for="objective">
        Objective
        <select id="objective">
          <option value="maximize-fidelity">Maximize DPD fidelity</option>
          <option value="minimize-latency">Minimize loop latency</option>
          <option value="info-vs-damage">Info gain vs back-action</option>
          <option value="stability-window">Stability window over time</option>
        </select>
      </label>

      <h3>Run control</h3>
      <div class="button-row">
        <button id="btnDryRun" class="small">Dry-run (no hardware)</button>
        <button id="btnLaunchRun" class="primary small">Launch run</button>
        <button id="btnKillRun" class="danger small">Kill switch</button>
      </div>
      <p class="help-text">
        Backend maps these to <code>/sessions/{id}/run</code> (mode=<code>run</code> or
        <code>dryrun</code>) and <code>/sessions/{id}/kill</code>, plus
        <code>num_iterations</code> and <code>shot_limit</code> hints.
      </p>
      <div id="lastRunInfo" class="run-info">No runs yet.</div>
    </section>

    <!-- KPIs -->
    <section class="panel panel--kpi">
      <h2>Live KPIs</h2>
      <div class="kpi-grid">
        <div class="kpi-card">
          <div class="kpi-title">
            <span>DPD fidelity</span>
            <span class="badge">target ≥ 0.975</span>
          </div>
          <div id="kpiFidelity" class="kpi-value">—</div>
          <div id="kpiFidelityDelta" class="kpi-sub">Awaiting run…</div>
        </div>
        <div class="kpi-card">
          <div class="kpi-title">
            <span>Latency (µs)</span>
            <span class="badge">loop end-to-end</span>
          </div>
          <div id="kpiLatency" class="kpi-value">—</div>
          <div id="kpiLatencyDelta" class="kpi-sub">Awaiting run…</div>
        </div>
        <div class="kpi-card">
          <div class="kpi-title">
            <span>Back-action</span>
            <span class="badge">info vs damage</span>
          </div>
          <div id="kpiBackaction" class="kpi-value">—</div>
          <div id="kpiBackactionHint" class="kpi-sub">Awaiting run…</div>
        </div>
        <div class="kpi-card">
          <div class="kpi-title">
            <span>Shot budget</span>
            <span class="badge">used / limit</span>
          </div>
          <div id="kpiShots" class="kpi-value">—</div>
          <div id="kpiShotsFraction" class="kpi-sub">No consumption yet.</div>
        </div>
      </div>
      <div class="qubit-visualizer" aria-hidden="false">
        <h3 style="margin-top:0.6rem; margin-bottom:0.25rem; font-size:0.9rem; color:var(--text-muted);">Qubit visualizer</h3>
        <div class="qubit-grid" style="display:flex; gap:0.6rem; align-items:center;">
          <div class="qubit-sphere" data-qubit="0" data-state="idle">
            <div class="qubit-sphere-inner">
              <div class="qubit-value">—</div>
            </div>
            <div class="qubit-meta">
              <div class="qubit-p0">P(0): —</div>
              <div class="qubit-p1">P(1): —</div>
            </div>
          </div>
          <div class="qubit-sphere" data-qubit="1" data-state="idle">
            <div class="qubit-sphere-inner">
              <div class="qubit-value">—</div>
            </div>
            <div class="qubit-meta">
              <div class="qubit-p0">P(0): —</div>
              <div class="qubit-p1">P(1): —</div>
            </div>
          </div>
          <div class="qubit-sphere" data-qubit="2" data-state="idle">
            <div class="qubit-sphere-inner">
              <div class="qubit-value">—</div>
            </div>
            <div class="qubit-meta">
              <div class="qubit-p0">P(0): —</div>
              <div class="qubit-p1">P(1): —</div>
            </div>
          </div>
          <div class="qubit-sphere" data-qubit="3" data-state="idle">
            <div class="qubit-sphere-inner">
              <div class="qubit-value">—</div>
            </div>
            <div class="qubit-meta">
              <div class="qubit-p0">P(0): —</div>
              <div class="qubit-p1">P(1): —</div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Telemetry -->
    <section class="panel panel--telemetry">
      <h2>Real-time telemetry</h2>
      <p class="help-text">
        Monitor live metrics from active hardware adapters / cloud backends via
        <code>/sessions/{id}/telemetry</code>.
      </p>
      <div class="grid-two telemetry-controls">
        <label>
          Poll interval (ms)
          <input
            id="telemetryInterval"
            type="number"
            min="250"
            max="10000"
            step="250"
            value="2000"
          />
        </label>
        <label>
          History depth
          <input
            id="telemetryDepth"
            type="number"
            min="8"
            max="256"
            step="8"
            value="64"
          />
        </label>
      </div>
      <div class="button-row">
        <button id="btnTelemetryStart" class="small">Start monitoring</button>
        <button id="btnTelemetryStop" class="small" disabled>Stop</button>
      </div>
      <div class="telemetry-table-wrapper">
        <table class="telemetry-table">
          <thead>
            <tr>
              <th>Timestamp</th>
              <th>Provider</th>
              <th>Fidelity</th>
              <th>Latency (µs)</th>
              <th>Shots used</th>
              <th>Shot rate</th>
            </tr>
          </thead>
          <tbody id="telemetryTableBody">
            <tr>
              <td colspan="6" class="telemetry-empty">No telemetry yet.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>

    <!-- Logs -->
    <section class="panel panel--log">
      <h2>Run log</h2>
      <p class="help-text">
        Backed by <code>/sessions/{id}/logs</code>. Combine with telemetry for full-stack
        monitoring.
      </p>
      <div class="button-row">
        <button id="btnRefreshLogs" class="small">Refresh log</button>
        <button id="btnClearLogs" class="small">Clear log</button>
        <label class="inline">
          <input id="autoRefreshLogs" type="checkbox" />
          <span class="help-text">Auto-refresh (3s)</span>
        </label>
      </div>
      <pre id="logsContent" class="log-output">No logs yet.</pre>
    </section>

    <!-- Export -->
    <section class="panel panel--export">
      <h2>Export</h2>
      <p class="help-text">
        Uses <code>/sessions/{id}/export?format=…</code>. Feed this into your notebooks or
        data lake.
      </p>
      <label for="exportFormat">
        Format
        <select id="exportFormat">
          <option value="json">JSON</option>
          <option value="csv">CSV</option>
          <option value="notebook">Notebook cell payload</option>
        </select>
      </label>
      <div class="button-row">
        <button id="btnExport" class="small">Export snapshot</button>
      </div>
      <textarea
        id="exportOutput"
        class="export-output"
        readonly
        spellcheck="false"
      >Waiting for export…</textarea>
    </section>

    <!-- Agent -->
    <section class="panel panel--agent">
      <h2>SynQc Copilot</h2>
      <p class="help-text">
        Conversational agent wired to <code>/chat</code>. Attach it to a model or rule engine on the backend.
      </p>
      <div class="chat-container">
        <div id="chatLog" class="chat-log">
          <div class="chat-msg chat-msg--assistant">
            <div class="chat-msg-meta">Agent</div>
            <div class="chat-msg-body">
              Ready. Ask about configurations, runs, or anomalous telemetry.
            </div>
          </div>
        </div>
        <div class="chat-input-row">
          <textarea
            id="chatInput"
            class="chat-input"
            rows="2"
            placeholder="e.g. 'Explain the back-action KPI for the last run.'"
          ></textarea>
          <div class="chat-button-column">
            <button id="btnChatSend" class="primary small">Send</button>
            <button id="btnChatClear" class="small">Clear</button>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Agent Chatbot -->
  <div class="agent-chat-container" id="agentChatContainer">
    <div class="agent-chat-header" id="agentChatHeader">
      <h3>LLM Agent Assistant</h3>
      <div style="display: flex; align-items: center; gap: 8px;">
        <div class="status-indicator"></div>
        <button class="agent-chat-minimize-btn" id="agentMinimizeBtn">−</button>
      </div>
    </div>
    <div class="agent-chat-body" id="agentChatBody">
      <div class="agent-message system">
        <div class="agent-message-bubble">
          Welcome to SynQc TDS Agent Assistant. Ask me about configuration, hardware, or run optimization.
        </div>
      </div>
    </div>
    <div class="agent-chat-footer">
      <input
        id="agentChatInput"
        type="text"
        placeholder="Ask the agent..."
        spellcheck="false"
        autocomplete="off"
      />
      <button id="agentSendBtn">Send</button>
    </div>
  </div>

  <script>
    (function () {
      const TARGET_FIDELITY = 0.975;

      const state = {
        apiBase: "",
        apiKey: "",
        health: null,
        session: null,
        lastRun: null,
        sessionsList: [],
        logs: [],
        exportFormat: "json",
        autosaveTimer: null,
        logTimer: null,
        statusTimer: null,
        telemetryTimer: null,
        totalShotsUsed: 0,
        totalShotLimit: 0,
        totalShotsInitialized: false,
          chatHistory: [],
      };

      function init() {
        const apiBaseInput = document.getElementById("apiBase");
        const apiKeyInput = document.getElementById("apiKey");

        let defaultBase = "";
        try {
          const origin = window.location.origin;
          if (origin && origin !== "null" && origin !== "file://") {
            defaultBase = origin.replace(/\/+$/, "") + "/api/v1/synqc";
          }
        } catch (e) {
          // ignore
        }

        if (!defaultBase) defaultBase = "http://localhost:8000/api/v1/synqc";
        apiBaseInput.value = defaultBase;
        state.apiBase = defaultBase;

        apiBaseInput.addEventListener("change", (e) => {
          state.apiBase = e.target.value.trim();
          showStatus("API base set to " + state.apiBase, "ok");
        });

        apiKeyInput.addEventListener("change", (e) => {
          state.apiKey = e.target.value.trim();
          showStatus("API key updated", "ok");
        });

        wireControls();
        initChatAgent();
        wireAgentChat();
        updateSessionHeader();
        updateKpis();
        updateExportOutput("Waiting for export…");
        updateShotsCounter();
        initBackgroundScene();
        resetQubitVisualizer();

        pingHealth().catch(() => {});
        refreshSessionList().catch(() => {});
      }

      document.addEventListener("DOMContentLoaded", init);

      function wireControls() {
        document.getElementById("btnHealth").addEventListener("click", () => {
          pingHealth().catch(() => {});
        });

        document
          .getElementById("btnRefreshSessions")
          .addEventListener("click", () => {
            refreshSessionList().catch(() => {});
          });

        document
          .getElementById("btnNewSession")
          .addEventListener("click", () => {
            createNewSessionFromConfig().catch(() => {});
          });

        document
          .getElementById("btnSaveSession")
          .addEventListener("click", () => {
            saveSessionConfig().catch(() => {});
          });

        [
          "hardwareTarget",
          "hardwarePreset",
          "driveEnvelope",
          "adaptiveRule",
          "objective",
          "numIterations",
          "shotLimit",
        ].forEach((id) => {
          const el = document.getElementById(id);
          if (el) el.addEventListener("change", scheduleAutosave);
        });

        const notes = document.getElementById("notes");
        if (notes) notes.addEventListener("change", scheduleAutosave);

        const probeStrength = document.getElementById("probeStrength");
        const probeDuration = document.getElementById("probeDuration");

        probeStrength.addEventListener("input", () =>
          updateProbeStrengthDisplay(parseFloat(probeStrength.value))
        );
        probeStrength.addEventListener("change", scheduleAutosave);

        probeDuration.addEventListener("input", () =>
          updateProbeDurationDisplay(parseInt(probeDuration.value, 10))
        );
        probeDuration.addEventListener("change", scheduleAutosave);

        updateProbeStrengthDisplay(parseFloat(probeStrength.value));
        updateProbeDurationDisplay(parseInt(probeDuration.value, 10));

        document
          .getElementById("btnDryRun")
          .addEventListener("click", () => {
            launchRun("dryrun").catch(() => {});
          });

        document
          .getElementById("btnLaunchRun")
          .addEventListener("click", () => {
            launchRun("run").catch(() => {});
          });

        document
          .getElementById("btnKillRun")
          .addEventListener("click", () => {
            killRun().catch(() => {});
          });

        document
          .getElementById("btnRefreshLogs")
          .addEventListener("click", () => {
            refreshLogs().catch(() => {});
          });

        document
          .getElementById("btnClearLogs")
          .addEventListener("click", () => {
            clearLogs().catch(() => {});
          });

        document
          .getElementById("autoRefreshLogs")
          .addEventListener("change", (e) => {
            setAutoRefreshLogs(e.target.checked);
          });

        const exportFormatSelect = document.getElementById("exportFormat");
        exportFormatSelect.addEventListener("change", (e) => {
          state.exportFormat = e.target.value;
        });

        document.getElementById("btnExport").addEventListener("click", () => {
          exportSnapshot().catch(() => {});
        });

        document
          .getElementById("btnTelemetryStart")
          .addEventListener("click", () => {
            startTelemetry().catch(() => {});
          });

        document
          .getElementById("btnTelemetryStop")
          .addEventListener("click", () => {
            stopTelemetry();
          });
      }

      function showStatus(message, level) {
        const bar = document.getElementById("globalStatus");
        bar.textContent = message;
        bar.setAttribute("data-level", level || "ok");
        bar.classList.add("visible");
        if (state.statusTimer) clearTimeout(state.statusTimer);
        state.statusTimer = setTimeout(() => {
          bar.classList.remove("visible");
        }, 4500);
      }

      function apiFetch(path, options) {
        const base = (state.apiBase || "").replace(/\/+$/, "");
        if (!base) return Promise.reject(new Error("API base URL is empty."));
        const url = base + path;
        const opts = options || {};
        const headers = opts.headers || {};
        if (opts.body && !("Content-Type" in headers)) {
          headers["Content-Type"] = "application/json";
        }
        if (state.apiKey) {
          headers["X-API-Key"] = state.apiKey;
        }
        opts.headers = headers;

        return fetch(url, opts).then((res) => {
          const ct = res.headers.get("content-type") || "";
          if (!res.ok) {
            if (ct.includes("application/json")) {
              return res.json().then((data) => {
                const detail = data && data.detail ? data.detail : res.statusText;
                throw new Error("HTTP " + res.status + ": " + detail);
              });
            }
            throw new Error("HTTP " + res.status + " for " + path);
          }
          if (ct.includes("application/json")) return res.json();
          return res.text();
        });
      }

      function pingHealth() {
        return apiFetch("/health")
          .then((data) => {
            state.health = data;
            const version = data.version || "?";
            const apiPrefix = data.api_prefix || state.apiBase;
            showStatus(
              "Backend healthy (v" + version + ") @ " + apiPrefix,
              "ok"
            );
          })
          .catch((err) => {
            showStatus("Health check failed: " + err.message, "error");
            throw err;
          });
      }

      function scheduleAutosave() {
        if (state.autosaveTimer) clearTimeout(state.autosaveTimer);
        // Increased debounce to reduce rapid save requests under heavy UI activity
        state.autosaveTimer = setTimeout(() => {
          saveSessionConfig().catch(() => {});
        }, 1000);
      }

      function buildConfigFromForm() {
        return {
          hardware_target: document.getElementById("hardwareTarget").value,
          hardware_preset: document.getElementById("hardwarePreset").value,
          drive_envelope: document.getElementById("driveEnvelope").value,
          probe_strength: parseFloat(document.getElementById("probeStrength").value),
          probe_duration_ns: parseInt(
            document.getElementById("probeDuration").value,
            10
          ),
          adaptive_rule: document.getElementById("adaptiveRule").value,
          objective: document.getElementById("objective").value,
          num_iterations_default: parseInt(
            document.getElementById("numIterations").value,
            10
          ),
          shot_limit_default: parseInt(
            document.getElementById("shotLimit").value,
            10
          ),
          notes: document.getElementById("notes").value || null,
        };
      }

      function applyConfigToForm(cfg) {
        if (!cfg) return;
        const set = (id, val) => {
          const el = document.getElementById(id);
          if (val !== undefined && el !== null) el.value = val;
        };

        set("hardwareTarget", cfg.hardware_target);
        set("hardwarePreset", cfg.hardware_preset);
        set("driveEnvelope", cfg.drive_envelope);
        set("adaptiveRule", cfg.adaptive_rule);
        set("objective", cfg.objective);

        if (typeof cfg.probe_strength === "number") {
          const s = document.getElementById("probeStrength");
          s.value = cfg.probe_strength;
          updateProbeStrengthDisplay(cfg.probe_strength);
        }

        if (typeof cfg.probe_duration_ns === "number") {
          const d = document.getElementById("probeDuration");
          d.value = cfg.probe_duration_ns;
          updateProbeDurationDisplay(cfg.probe_duration_ns);
        }

        if (typeof cfg.num_iterations_default === "number") {
          set("numIterations", cfg.num_iterations_default);
        }

        if (typeof cfg.shot_limit_default === "number") {
          set("shotLimit", cfg.shot_limit_default);
        }

        document.getElementById("notes").value = cfg.notes || "";
      }

      function updateProbeStrengthDisplay(v) {
        if (!isFinite(v)) v = 0;
        document.getElementById("probeStrengthValue").textContent = v.toFixed(3);
      }

      function updateProbeDurationDisplay(v) {
        if (!isFinite(v)) v = 0;
        document.getElementById("probeDurationValue").textContent = v.toFixed(0);
      }

      function createNewSessionFromConfig() {
        const cfg = buildConfigFromForm();
        return apiFetch("/sessions", {
          method: "POST",
          body: JSON.stringify({ session_id: null, config: cfg }),
        })
          .then((session) => {
            state.session = session;
            state.lastRun = null;
            state.totalShotsUsed = 0;
            state.totalShotLimit = 0;
            state.totalShotsInitialized = false;
            updateSessionHeader();
            updateKpis();
            updateShotsCounter();
            resetQubitVisualizer();
            showStatus("Created session " + session.session_id, "ok");
            return refreshSessionList();
          })
          .catch((err) => {
            showStatus("Failed to create session: " + err.message, "error");
            throw err;
          });
      }

      function saveSessionConfig() {
        const cfg = buildConfigFromForm();
        const sessionId =
          state.session && state.session.session_id
            ? state.session.session_id
            : null;
        return apiFetch("/sessions", {
          method: "POST",
          body: JSON.stringify({ session_id: sessionId, config: cfg }),
        })
          .then((session) => {
            state.session = session;
            updateSessionHeader();
            updateKpis();
            showStatus("Saved configuration to " + session.session_id, "ok");
            return refreshSessionList();
          })
          .catch((err) => {
            showStatus("Failed to save config: " + err.message, "error");
            throw err;
          });
      }

      function refreshSessionList() {
        return apiFetch("/sessions")
          .then((sessions) => {
            state.sessionsList = Array.isArray(sessions) ? sessions : [];
            renderSessionList();
          })
          .catch((err) => {
            showStatus("Failed to list sessions: " + err.message, "error");
            throw err;
          });
      }

      function renderSessionList() {
        const container = document.getElementById("sessionList");
        container.innerHTML = "";
        if (!state.sessionsList.length) {
          const p = document.createElement("p");
          p.className = "help-text";
          p.style.padding = "0.3rem 0.4rem";
          p.textContent = "No sessions on disk yet.";
          container.appendChild(p);
          return;
        }

        state.sessionsList
          .slice()
          .sort(
            (a, b) =>
              new Date(b.last_updated_at || b.created_at || 0).getTime() -
              new Date(a.last_updated_at || a.created_at || 0).getTime()
          )
          .forEach((session) => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "session-row";

            const idSpan = document.createElement("span");
            idSpan.className = "session-row-id";
            idSpan.textContent = session.session_id;

            const statusSpan = document.createElement("span");
            statusSpan.className = "session-row-status";
            statusSpan.textContent =
              session.status_text || session.status || "";

            btn.appendChild(idSpan);
            btn.appendChild(statusSpan);

            const active =
              state.session &&
              state.session.session_id === session.session_id;
            if (active) btn.classList.add("active");

            btn.addEventListener("click", () => {
              loadSession(session.session_id).catch(() => {});
            });

            container.appendChild(btn);
          });
      }

      function loadSession(sessionId) {
        return apiFetch(
          "/sessions/" + encodeURIComponent(sessionId)
        )
          .then((session) => {
            state.session = session;
            state.lastRun = null;
            state.totalShotsUsed = 0;
            state.totalShotLimit = 0;
            state.totalShotsInitialized = false;
            applyConfigToForm(session.config);
            updateSessionHeader();
            updateKpis();
            updateShotsCounter();
            resetQubitVisualizer();
            showStatus("Loaded session " + sessionId, "ok");
            renderSessionList();
            return refreshLogs();
          })
          .catch((err) => {
            showStatus("Failed to load session: " + err.message, "error");
            throw err;
          });
      }

      function updateSessionHeader() {
        const modeEl = document.getElementById("sessionModeLabel");
        const idEl = document.getElementById("sessionId");
        const statusEl = document.getElementById("sessionStatus");

        if (!state.session) {
          modeEl.textContent = "Local Simulation";
          idEl.textContent = "—";
          statusEl.textContent = "No session yet";
          return;
        }

        modeEl.textContent = state.session.mode_label || "Session";
        idEl.textContent = state.session.session_id;
        statusEl.textContent =
          state.session.status_text || state.session.status || "";
      }

      function updateKpis() {
        const k = state.session ? state.session.last_kpis : null;

        const fidelityEl = document.getElementById("kpiFidelity");
        const fidelityDeltaEl = document.getElementById("kpiFidelityDelta");
        const latencyEl = document.getElementById("kpiLatency");
        const latencyDeltaEl = document.getElementById("kpiLatencyDelta");
        const backEl = document.getElementById("kpiBackaction");
        const backHintEl = document.getElementById("kpiBackactionHint");
        const shotsEl = document.getElementById("kpiShots");
        const shotsFracEl = document.getElementById("kpiShotsFraction");

        fidelityDeltaEl.classList.remove("positive", "negative");
        latencyDeltaEl.classList.remove("positive", "negative");
        backHintEl.classList.remove("positive", "negative");

        if (!k) {
          fidelityEl.textContent = "—";
          fidelityDeltaEl.textContent = "Awaiting run…";
          latencyEl.textContent = "—";
          latencyDeltaEl.textContent = "Awaiting run…";
          backEl.textContent = "—";
          backHintEl.textContent = "Awaiting run…";
          shotsEl.textContent = "—";
          shotsFracEl.textContent = "No consumption yet.";
          return;
        }

        const fid = Number(k.fidelity);
        const lat = Number(k.latency_us);
        const back = Number(k.backaction);
        const shotsUsed = Number(k.shots_used);
        const shotLimit = Number(k.shot_limit);
        const frac =
          typeof k.shots_used_fraction === "number"
            ? k.shots_used_fraction
            : shotLimit > 0
            ? Math.min(1, Math.max(0, shotsUsed / shotLimit))
            : 0;

        fidelityEl.textContent = fid.toFixed(3);
        const delta = fid - TARGET_FIDELITY;
        if (Math.abs(delta) < 1e-4) {
          fidelityDeltaEl.textContent = "At target";
        } else if (delta > 0) {
          fidelityDeltaEl.textContent =
            "+" + delta.toFixed(3) + " vs target";
          fidelityDeltaEl.classList.add("positive");
        } else {
          fidelityDeltaEl.textContent = delta.toFixed(3) + " vs target";
          fidelityDeltaEl.classList.add("negative");
        }

        latencyEl.textContent = lat.toFixed(1);
        if (lat < 20) {
          latencyDeltaEl.textContent = "Fast loop";
          latencyDeltaEl.classList.add("positive");
        } else if (lat > 80) {
          latencyDeltaEl.textContent = "High latency";
          latencyDeltaEl.classList.add("negative");
        } else {
          latencyDeltaEl.textContent = "Moderate latency";
        }

        backEl.textContent = back.toFixed(3);
        if (back < 0.25) {
          backHintEl.textContent = "Back-action acceptable";
          backHintEl.classList.add("positive");
        } else if (back > 0.6) {
          backHintEl.textContent = "Back-action heavy – ease ε";
          backHintEl.classList.add("negative");
        } else {
          backHintEl.textContent = "Balanced regime";
        }

        shotsEl.textContent =
          formatShots(shotsUsed) + " / " + formatShots(shotLimit);
        shotsFracEl.textContent = (frac * 100).toFixed(1) + "% consumed";

        if (!state.totalShotsInitialized) {
          state.totalShotsUsed = shotsUsed;
          state.totalShotLimit = shotLimit;
          state.totalShotsInitialized = true;
        }

        updateShotsCounter();
      }

      function updateShotsCounter() {
        const el = document.getElementById("shotsCounter");
        if (!el) return;
        const used = state.totalShotsUsed || 0;
        const limit = state.totalShotLimit || 0;
        if (limit > 0) {
          el.textContent =
            formatShots(used) + " / " + formatShots(limit);
        } else {
          el.textContent = formatShots(used);
        }
      }

      function formatShots(n) {
        if (!isFinite(n) || n < 0) return "0";
        if (n >= 1_000_000) return (n / 1_000_000).toFixed(1) + "M";
        if (n >= 1_000) return (n / 1_000).toFixed(1) + "k";
        return String(Math.round(n));
      }

      function launchRun(mode) {
        if (!state.session || !state.session.session_id) {
          showStatus("Create or load a session first.", "warn");
          return Promise.resolve();
        }

        const sessionId = state.session.session_id;

        const numIterations = parseInt(
          document.getElementById("numIterations").value,
          10
        );
        const shotLimit = parseInt(
          document.getElementById("shotLimit").value,
          10
        );

        const payload = {
          mode: mode === "dryrun" ? "dryrun" : "run",
          num_iterations: isFinite(numIterations) ? numIterations : undefined,
          shot_limit: isFinite(shotLimit) ? shotLimit : undefined,
        };

        const runBtn = document.getElementById("btnLaunchRun");
        const dryBtn = document.getElementById("btnDryRun");
        runBtn.disabled = true;
        dryBtn.disabled = true;

        return apiFetch(
          "/sessions/" + encodeURIComponent(sessionId) + "/run",
          {
            method: "POST",
            body: JSON.stringify(payload),
          }
        )
          .then((resp) => {
            state.session = resp.session;
            state.lastRun = resp.run;
            if (resp.run) {
              try {
                updateQubitVisualizerFromRun(resp.run);
              } catch (e) {
                console.warn('Qubit visualizer update failed', e);
              }
            }

            if (resp.run && resp.run.kpis) {
              const rk = resp.run.kpis;
              if (isFinite(rk.shots_used)) {
                state.totalShotsUsed += rk.shots_used;
              }
              if (isFinite(rk.shot_limit)) {
                state.totalShotLimit += rk.shot_limit;
              }
            }

            updateSessionHeader();
            updateKpis();
            updateShotsCounter();
            renderSessionList();
            updateLastRunInfo();
            showStatus(
              "Run " + resp.run.run_id + " completed (" + resp.run.mode + ")",
              "ok"
            );
            return refreshLogs();
          })
          .catch((err) => {
            showStatus("Run failed: " + err.message, "error");
            throw err;
          })
          .finally(() => {
            runBtn.disabled = false;
            dryBtn.disabled = false;
          });
      }

      function updateLastRunInfo() {
        const el = document.getElementById("lastRunInfo");
        const run = state.lastRun;
        if (!run) {
          el.textContent = "No runs yet.";
          return;
        }

        const ts = run.created_at || "";
        const modeLabel = run.mode === "dryrun" ? "dry-run" : "run";
        const k = run.kpis;

        let summary = "";
        if (k) {
          summary =
            " · fidelity=" +
            k.fidelity.toFixed(3) +
            ", latency=" +
            k.latency_us.toFixed(1) +
            "µs, back-action=" +
            k.backaction.toFixed(3) +
            ", shots=" +
            formatShots(k.shots_used) +
            "/" +
            formatShots(k.shot_limit);
        }

        el.innerHTML =
          "Last " +
          modeLabel +
          ' <code>' +
          run.run_id +
          "</code> @ " +
          ts +
          summary;
      }

      function killRun() {
        if (!state.session || !state.session.session_id) {
          showStatus("No active session to kill.", "warn");
          return Promise.resolve();
        }

        const sessionId = state.session.session_id;

        return apiFetch(
          "/sessions/" + encodeURIComponent(sessionId) + "/kill",
          {
            method: "POST",
          }
        )
          .then(() =>
            apiFetch(
              "/sessions/" + encodeURIComponent(sessionId)
            ).then((session) => {
              state.session = session;
              updateSessionHeader();
              showStatus("Kill switch pressed for " + sessionId, "ok");
              return refreshLogs();
            })
          )
          .catch((err) => {
            showStatus("Kill switch failed: " + err.message, "error");
            throw err;
          });
      }

      function refreshLogs() {
        if (!state.session || !state.session.session_id) {
          document.getElementById("logsContent").textContent =
            "No session loaded.";
          return Promise.resolve();
        }

        const sessionId = state.session.session_id;

        return apiFetch(
          "/sessions/" + encodeURIComponent(sessionId) + "/logs?limit=200"
        )
          .then((resp) => {
            const lines = resp && resp.lines ? resp.lines : [];
            state.logs = lines;
            renderLogs();
          })
          .catch((err) => {
            showStatus("Failed to fetch logs: " + err.message, "error");
            throw err;
          });
      }

      function renderLogs() {
        const pre = document.getElementById("logsContent");
        if (!state.logs.length) {
          pre.textContent = "No logs yet.";
          return;
        }
        pre.textContent = state.logs.join("\n");
      }

      function clearLogs() {
        if (!state.session || !state.session.session_id) {
          showStatus("No session loaded to clear logs.", "warn");
          return Promise.resolve();
        }

        const sessionId = state.session.session_id;

        return apiFetch(
          "/sessions/" + encodeURIComponent(sessionId) + "/logs",
          {
            method: "DELETE",
          }
        )
          .then(() => {
            showStatus("Logs cleared for " + sessionId, "ok");
            return refreshLogs();
          })
          .catch((err) => {
            showStatus("Failed to clear logs: " + err.message, "error");
            throw err;
          });
      }

      function setAutoRefreshLogs(enabled) {
        if (state.logTimer) {
          clearInterval(state.logTimer);
          state.logTimer = null;
        }
        if (!enabled) return;

        state.logTimer = setInterval(() => {
          if (!state.session || !state.session.session_id) return;
          refreshLogs().catch(() => {});
        }, 3000);
      }

      function exportSnapshot() {
        if (!state.session || !state.session.session_id) {
          showStatus("No session loaded for export.", "warn");
          return Promise.resolve();
        }

        const sessionId = state.session.session_id;
        const format = state.exportFormat || "json";
        const path =
          "/sessions/" +
          encodeURIComponent(sessionId) +
          "/export?format=" +
          encodeURIComponent(format);

        return apiFetch(path)
          .then((resp) => {
            if (!resp || typeof resp !== "object") {
              updateExportOutput(String(resp));
              showStatus("Export completed.", "ok");
              return;
            }

            if (resp.format === "json") {
              updateExportOutput(
                JSON.stringify(resp.payload, null, 2) + "\n"
              );
            } else {
              updateExportOutput(String(resp.payload || ""));
            }

            showStatus("Exported snapshot as " + resp.format, "ok");
          })
          .catch((err) => {
            showStatus("Export failed: " + err.message, "error");
            throw err;
          });
      }

      function updateExportOutput(text) {
        const el = document.getElementById("exportOutput");
        el.value = text || "";
      }

      function startTelemetry() {
        if (!state.session || !state.session.session_id) {
          showStatus("No session loaded for telemetry.", "warn");
          return Promise.resolve();
        }

        const intervalInput = document.getElementById("telemetryInterval");
        let intervalMs = parseInt(intervalInput.value, 10);
        if (!isFinite(intervalMs) || intervalMs < 250) intervalMs = 250;
        if (intervalMs > 10000) intervalMs = 10000;
        intervalInput.value = intervalMs;

        if (state.telemetryTimer) {
          clearInterval(state.telemetryTimer);
          state.telemetryTimer = null;
        }

        const btnStart = document.getElementById("btnTelemetryStart");
        const btnStop = document.getElementById("btnTelemetryStop");
        btnStart.disabled = true;
        btnStop.disabled = false;

        return pollTelemetry()
          .then(() => {
            showStatus(
              "Telemetry monitoring started (" + intervalMs + " ms interval).",
              "ok"
            );
            state.telemetryTimer = setInterval(() => {
              pollTelemetry().catch(() => {});
            }, intervalMs);
          })
          .catch((err) => {
            showStatus("Telemetry error: " + err.message, "error");
            btnStart.disabled = false;
            btnStop.disabled = true;
            throw err;
          });
      }

      function stopTelemetry() {
        if (state.telemetryTimer) {
          clearInterval(state.telemetryTimer);
          state.telemetryTimer = null;
        }
        const btnStart = document.getElementById("btnTelemetryStart");
        const btnStop = document.getElementById("btnTelemetryStop");
        btnStart.disabled = false;
        btnStop.disabled = true;
        showStatus("Telemetry monitoring stopped.", "ok");
      }

      function pollTelemetry() {
        if (!state.session || !state.session.session_id) {
          return Promise.resolve();
        }

        const sessionId = state.session.session_id;
        const depthInput = document.getElementById("telemetryDepth");
        let depth = parseInt(depthInput.value, 10);
        if (!isFinite(depth) || depth < 8) depth = 8;
        if (depth > 256) depth = 256;
        depthInput.value = depth;

        const path =
          "/sessions/" +
          encodeURIComponent(sessionId) +
          "/telemetry?limit=" +
          depth;

        return apiFetch(path)
          .then((resp) => {
            let rows = [];
            if (Array.isArray(resp)) {
              rows = resp;
            } else if (resp && Array.isArray(resp.rows)) {
              rows = resp.rows;
            } else if (resp && Array.isArray(resp.data)) {
              rows = resp.data;
            }
            renderTelemetry(rows);
          })
          .catch((err) => {
            // Keep telemetry errors soft so logs/other features still work.
            showStatus("Telemetry fetch failed: " + err.message, "warn");
            throw err;
          });
      }

      function renderTelemetry(rows) {
        const tbody = document.getElementById("telemetryTableBody");
        tbody.innerHTML = "";

        if (!rows || !rows.length) {
          const tr = document.createElement("tr");
          const td = document.createElement("td");
          td.colSpan = 6;
          td.className = "telemetry-empty";
          td.textContent = "No telemetry yet.";
          tr.appendChild(td);
          tbody.appendChild(tr);
          return;
        }

        rows.forEach((row) => {
          const tr = document.createElement("tr");
          const ts = row.timestamp || row.t || row.time || "";
          const provider = row.provider || row.backend || row.hardware || "";
          const fid = formatMaybeNumber(row.fidelity);
          const lat =
            typeof row.latency_us === "number" && isFinite(row.latency_us)
              ? row.latency_us.toFixed(1)
              : row.latency_us != null
              ? String(row.latency_us)
              : "—";
          const shots = formatShots(row.shots_used || 0);
          let rate = "—";
          if (
            typeof row.shot_rate === "number" &&
            isFinite(row.shot_rate)
          ) {
            rate = row.shot_rate.toFixed(1) + "/s";
          } else if (row.shot_rate != null) {
            rate = String(row.shot_rate);
          }

          [
            ts || "—",
            provider || "—",
            fid,
            lat,
            shots,
            rate,
          ].forEach((val) => {
            const td = document.createElement("td");
            td.textContent = val;
            tr.appendChild(td);
          });

          tbody.appendChild(tr);
        });
      }

      function formatMaybeNumber(v) {
        if (typeof v === "number" && isFinite(v)) {
          return v.toFixed(3);
        }
        return v != null ? String(v) : "—";
      }
       function initBackgroundScene() {
         // Avoid double init in case of hot reloads.
         if (document.getElementById("bgScene")) return;

         const canvas = document.createElement("canvas");
         canvas.id = "bgScene";
         canvas.className = "bg-scene";
         // Put it at the very top of <body> so everything else stacks above.
         document.body.insertBefore(canvas, document.body.firstChild);

         const ctx = canvas.getContext("2d");

         let width = 0;
         let height = 0;
         let dpr = window.devicePixelRatio || 1;

         const PARTICLE_COUNT = 140;
         const ATOM_COUNT = 7;

         const particles = [];
         const atoms = [];

         function resize() {
           width = window.innerWidth || document.documentElement.clientWidth || 1280;
           height = window.innerHeight || document.documentElement.clientHeight || 720;
           dpr = window.devicePixelRatio || 1;

           canvas.width = width * dpr;
           canvas.height = height * dpr;
           canvas.style.width = width + "px";
           canvas.style.height = height + "px";
           ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
         }

         function spawnParticles() {
           particles.length = 0;
           for (let i = 0; i < PARTICLE_COUNT; i++) {
             particles.push({
               x: Math.random() * width,
               y: Math.random() * height,
               vx: (Math.random() - 0.5) * 0.12,
               vy: (Math.random() - 0.5) * 0.12,
               r: 0.6 + Math.random() * 1.6,
               alpha: 0.25 + Math.random() * 0.5,
               twinkle: 0.4 + Math.random() * 0.8
             });
           }
         }

         function spawnAtoms() {
           atoms.length = 0;
           for (let i = 0; i < ATOM_COUNT; i++) {
             const radius = 26 + Math.random() * 40;
             const cx = Math.random() * width;
             const cy = Math.random() * height;

             const electronCount = 2 + Math.floor(Math.random() * 3);
             const electrons = [];

             for (let e = 0; e < electronCount; e++) {
               electrons.push({
                 orbitRadius: radius * (0.7 + Math.random() * 0.4),
                 angle: Math.random() * Math.PI * 2,
                 speed: (0.3 + Math.random() * 0.6) * (Math.random() < 0.5 ? -1 : 1)
               });
             }

             atoms.push({
               x: cx,
               y: cy,
               baseRadius: radius,
               electrons,
               wobblePhase: Math.random() * Math.PI * 2
             });
           }
         }

         function tick(timestamp) {
           const t = timestamp * 0.001;

           ctx.clearRect(0, 0, width, height);

           // --- Particles ---
           for (let i = 0; i < particles.length; i++) {
             const p = particles[i];
             p.x += p.vx;
             p.y += p.vy;

             if (p.x < -20) p.x = width + 20;
             if (p.x > width + 20) p.x = -20;
             if (p.y < -20) p.y = height + 20;
             if (p.y > height + 20) p.y = -20;

             const twinkle = 0.6 + 0.4 * Math.sin(t * p.twinkle + i);
             const alpha = p.alpha * twinkle;

             const gradient = ctx.createRadialGradient(
               p.x, p.y, 0,
               p.x, p.y, p.r * 3
             );
             gradient.addColorStop(0, "rgba(255,255,255," + alpha + ")");
             gradient.addColorStop(1, "rgba(83,168,255,0)");

             ctx.fillStyle = gradient;
             ctx.beginPath();
             ctx.arc(p.x, p.y, p.r * 3, 0, Math.PI * 2);
             ctx.fill();
           }

           // --- Soft connections between nearby particles ---
           for (let i = 0; i < particles.length; i++) {
             const p1 = particles[i];
             for (let j = i + 1; j < particles.length; j++) {
               const p2 = particles[j];
               const dx = p1.x - p2.x;
               const dy = p1.y - p2.y;
               const dist2 = dx * dx + dy * dy;
               const maxDist = 130;
               if (dist2 < maxDist * maxDist) {
                 const alpha = 0.22 * (1 - Math.sqrt(dist2) / maxDist);
                 ctx.strokeStyle = "rgba(83,168,255," + alpha + ")";
                 ctx.lineWidth = 0.6;
                 ctx.beginPath();
                 ctx.moveTo(p1.x, p1.y);
                 ctx.lineTo(p2.x, p2.y);
                 ctx.stroke();
               }
             }
           }

           // --- Atom orbits / electrons ---
           atoms.forEach((atom, index) => {
             const wobble = Math.sin(t * 0.25 + atom.wobblePhase) * 6;
             const cx = atom.x + wobble;
             const cy = atom.y - wobble * 0.6;

             // Orbit ring (tilted ellipse)
             ctx.save();
             ctx.translate(cx, cy);
             const tilt = 0.2 + (index % 3) * 0.25;
             ctx.scale(1, tilt);
             ctx.strokeStyle = "rgba(156,196,255,0.45)";
             ctx.lineWidth = 0.6;
             ctx.beginPath();
             ctx.arc(0, 0, atom.baseRadius, 0, Math.PI * 2);
             ctx.stroke();
             ctx.restore();

             // Electrons
             atom.electrons.forEach((e) => {
               const angle = e.angle + t * e.speed;
               const ex = cx + Math.cos(angle) * e.orbitRadius;
               const ey = cy + Math.sin(angle) * e.orbitRadius * 0.55;

               const grd = ctx.createRadialGradient(ex, ey, 0, ex, ey, 7);
               grd.addColorStop(0, "rgba(255,221,110,0.95)");
               grd.addColorStop(1, "rgba(255,221,110,0)");

               ctx.fillStyle = grd;
               ctx.beginPath();
               ctx.arc(ex, ey, 4, 0, Math.PI * 2);
               ctx.fill();
             });

             // Nucleus glow
             const coreRadius = atom.baseRadius * 0.65;
             const coreGradient = ctx.createRadialGradient(
               cx, cy, 0,
               cx, cy, coreRadius * 1.4
             );
             coreGradient.addColorStop(0, "rgba(83,168,255,0.9)");
             coreGradient.addColorStop(0.6, "rgba(155,92,255,0.5)");
             coreGradient.addColorStop(1, "rgba(5,7,20,0)");

             ctx.fillStyle = coreGradient;
             ctx.beginPath();
             ctx.arc(cx, cy, coreRadius * 1.4, 0, Math.PI * 2);
             ctx.fill();
           });

           requestAnimationFrame(tick);
         }

         resize();
         spawnParticles();
         spawnAtoms();

         window.addEventListener("resize", () => {
           resize();
           spawnParticles();
           spawnAtoms();
         });

         requestAnimationFrame(tick);
       }

       function wireAgentChat() {
         const container = document.getElementById("agentChatContainer");
         const header = document.getElementById("agentChatHeader");
         const body = document.getElementById("agentChatBody");
         const input = document.getElementById("agentChatInput");
         const sendBtn = document.getElementById("agentSendBtn");
         const minimizeBtn = document.getElementById("agentMinimizeBtn");

         let isMinimized = false;

         // Minimize/maximize toggle
         header.addEventListener("click", () => {
           isMinimized = !isMinimized;
           container.classList.toggle("minimized", isMinimized);
           minimizeBtn.textContent = isMinimized ? "+" : "−";
         });

         minimizeBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           isMinimized = !isMinimized;
           container.classList.toggle("minimized", isMinimized);
           minimizeBtn.textContent = isMinimized ? "+" : "−";
         });

         // Send message on button click or Enter key
         const sendMessage = () => {
           const text = input.value.trim();
           if (!text) return;

           // Add user message
           const userMsg = document.createElement("div");
           userMsg.className = "agent-message user";
           userMsg.innerHTML = '<div class="agent-message-bubble">' + escapeHtml(text) + "</div>";
           body.appendChild(userMsg);

           input.value = "";
           input.focus();

           // Scroll to bottom
           setTimeout(() => {
             body.scrollTop = body.scrollHeight;
           }, 0);

           // Simulate agent response with typing indicator
           const loadingMsg = document.createElement("div");
           loadingMsg.className = "agent-message agent";
           loadingMsg.innerHTML =
             '<div class="agent-message-bubble agent-message-loading">' +
             '<span class="agent-message-dot"></span>' +
             '<span class="agent-message-dot"></span>' +
             '<span class="agent-message-dot"></span>' +
             "</div>";
           body.appendChild(loadingMsg);
           body.scrollTop = body.scrollHeight;

           // Simulate agent thinking (in production, call real API)
           setTimeout(() => {
             loadingMsg.remove();

             const agentMsg = document.createElement("div");
             agentMsg.className = "agent-message agent";
             const response = generateAgentResponse(text);
             agentMsg.innerHTML = '<div class="agent-message-bubble">' + escapeHtml(response) + "</div>";
             body.appendChild(agentMsg);

             body.scrollTop = body.scrollHeight;
           }, 800);
         };

         sendBtn.addEventListener("click", sendMessage);
         input.addEventListener("keydown", (e) => {
           if (e.key === "Enter" && !e.shiftKey) {
             e.preventDefault();
             sendMessage();
           }
         });
       }

       function generateAgentResponse(userQuery) {
         const q = userQuery.toLowerCase();

         if (q.includes("help") || q.includes("?")) {
           return "I can help with:\n• Configuration guidance\n• Hardware recommendations\n• Run optimization\n• Troubleshooting\n\nWhat would you like to know?";
         }

         if (q.includes("config") || q.includes("configure")) {
           return "Configuration tips:\n• Set probe strength (ε) between 0.1–0.5 for optimal fidelity\n• Choose Gaussian or DRAG envelopes for most hardware\n• Increase iterations for better convergence\n\nNeed specific help?";
         }

         if (q.includes("fidelity") || q.includes("target") || q.includes("975")) {
           return "DPD fidelity target is ≥0.975:\n• Increase probe duration for better resolution\n• Reduce hardware noise (lower temperature)\n• Try adaptive rules (Kalman/Bayesian)\n\nCurrent session showing live KPIs above.";
         }

         if (q.includes("hardware") || q.includes("quantum")) {
           return "Supported hardware:\n• IBM Quantum QPU (5–27 qubits)\n• AWS Bracket\n• IonQ (trapped ions)\n• Neutral atom arrays (100+ sites)\n\nSelect from Hardware Stack panel.";
         }

         if (q.includes("latency") || q.includes("speed") || q.includes("fast")) {
           return "To minimize loop latency:\n• Use local simulator for testing\n• Batch multiple shots\n• Reduce telemetry polling interval\n• Consider classical-only mode for prototyping";
         }

         if (q.includes("shot") || q.includes("budget")) {
           return "Shot budget management:\n• Default: 4096 shots/run\n• Increase for statistical confidence\n• Export snapshots to avoid re-running\n• Monitor consumption in KPIs panel";
         }

         return "I'm here to help with SynQc TDS! Try asking about:\n• Configuration\n• Fidelity targets\n• Hardware selection\n• Latency optimization\n• Shot budget";
       }

       function escapeHtml(text) {
         const map = {
           "&": "&amp;",
           "<": "&lt;",
           ">": "&gt;",
           '"': "&quot;",
           "'": "&#039;"
         };
         return text.replace(/[&<>"']/g, (c) => map[c]);
       }
      
      // Qubit visualizer helpers
      function resetQubitVisualizer() {
        try {
          const nodes = document.querySelectorAll('.qubit-sphere');
          nodes.forEach((n) => {
            n.setAttribute('data-state', 'idle');
            const val = n.querySelector('.qubit-value');
            if (val) val.textContent = '—';
            const p0 = n.querySelector('.qubit-p0');
            const p1 = n.querySelector('.qubit-p1');
            if (p0) p0.textContent = 'P(0): —';
            if (p1) p1.textContent = 'P(1): —';
          });
        } catch (e) {
          // silent
        }
      }

      function updateQubitVisualizerFromRun(run) {
        if (!run || !run.measurements || !Array.isArray(run.measurements)) return;
        try {
          run.measurements.forEach((m) => {
            const q = typeof m.qubit !== 'undefined' ? String(m.qubit) : null;
            if (!q) return;
            const node = document.querySelector('.qubit-sphere[data-qubit="' + q + '"]');
            if (!node) return;
            // choose state based on probabilities
            const p0 = isFinite(m.p0) ? m.p0 : null;
            const p1 = isFinite(m.p1) ? m.p1 : null;
            if (p0 != null && p1 != null) {
              if (p0 > 0.85) node.setAttribute('data-state', 'zero');
              else if (p1 > 0.85) node.setAttribute('data-state', 'one');
              else node.setAttribute('data-state', 'superposition');
            } else if (typeof m.last !== 'undefined') {
              node.setAttribute('data-state', m.last === 0 ? 'zero' : 'one');
            }

            const val = node.querySelector('.qubit-value');
            if (val) {
              if (typeof m.last !== 'undefined') val.textContent = String(m.last);
              else val.textContent = '—';
            }

            const p0el = node.querySelector('.qubit-p0');
            const p1el = node.querySelector('.qubit-p1');
            if (p0el) p0el.textContent = 'P(0): ' + (p0 != null ? p0.toFixed(3) : '—');
            if (p1el) p1el.textContent = 'P(1): ' + (p1 != null ? p1.toFixed(3) : '—');
          });
        } catch (e) {
          console.warn('Failed to update qubit visualizer', e);
        }
      }
    })();
  </script>
</body>
</html>
